[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ciencia de datos con Julia",
    "section": "",
    "text": "Prólogo\nEste projecto lo inicio por haber querido emplear Julia en el ámbito profesional y no haber podido. Es mucho más habitual en mi entorno, por familiaridad y conveniencia, que los proyectos de ciencia de datos se realicen en otros lenguajes de programación. Sin embargo, quiero romper una lanza a favor de Julia como el lenguaje a emplear en ciencia de datos por su rendimiento y proximidad al dominio científico. Existen guía excepcionales en inglés:\nY algunas muy buenas referencias de programación en Julia en Español.\nPero este es mi intento de acercarlo al público hispanohablante. Teniendo referencias en el idioma de uno es más fácil poder adoptar algo y crear una comunidad con contribuya tanto como lo hace la comunidad de Python.\nCon suerte este libro ayuda a más de uno a perder el miedo y enfrentarse a este lenguaje que no deja de ser uno de los motivos por los que nuestros amados notebooks son notebooks de Jupyter (Julia, python y R).",
    "crumbs": [
      "Prólogo"
    ]
  },
  {
    "objectID": "index.html#sobre-mí",
    "href": "index.html#sobre-mí",
    "title": "Ciencia de datos con Julia",
    "section": "Sobre mí",
    "text": "Sobre mí\nMi nombre es Iraitz Montalbán y llevo… algo de tiempo en esto de la ciencia de datos e inteligencia artificial. Puedes contactar directamente conmigo en iraitz.info.\n\n\n\n\nStoropoli, Jose, Rik Huijzer, y Lazaro Alonso. 2021. Julia Data Science. https://juliadatascience.io.",
    "crumbs": [
      "Prólogo"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introducción",
    "section": "",
    "text": "1.1 Instalar Julia\nPrimeramente debemos entender qué es Julia (Bezanson et al. 2017). Julia es un lenguaje de reciente creación (2012) de programación que pretende romper la barrera de los dos lenguajes. Es decir, ser rápido en ejecución pero cómodo en el uso, incluyendo el uso interactivo tan común en el trabajo exploratorio de la ciencia de datos. Está muy ligado al mundo de la computación científica y es común en centros de investigación o entes ligados a la computación de altas prestaciones (High Performance Computing). De hecho, Julia es parte del selecto club del petaflop. Está basado en el compilador LLVM (Lattner y Adve 2004) y de ahí que muestra una velocidad similar a la de otros lenguajes empleados en ambientes productivos (C/C++, Rust o Go).\nEs habitual que los científicos de datos desarrollen sus modelos en Python y una vez conformes con su rendimiento delegen la puesta en producción en ingenieros que deben transformar estos programas en código productivo. Suele requerir incorporar cuestiones no contempladas hasta el momento como logs de cara a depurar errores, bloques de seguridad y autenticación, sanitización1 del código para evitar problemas de seguridad y rendimiento, etc.\nJulia no podría ser más sencillo de instalar.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#instalar-julia",
    "href": "intro.html#instalar-julia",
    "title": "1  Introducción",
    "section": "",
    "text": "1.1.1 Linux/Mac\nSimplemente ejecuta el comando\ncurl -fsSL https://install.julialang.org | sh\ny se encargará de instalar el intérprete de Julia así como su gestor de versiones juliaup.\n\n\n1.1.2 Windows\nDeberemos instalarlo desde la Microsoft Store pero también podemos ejecutarlo desde una shell.\nwinget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\nUna vez instalado podemos hacer una pequeña prueba, levantar un terminal y ejecutar julia. Debería mostrarnos algo como\n\n\n\nJulia en el terminal\n\n\nAhora ya solo nos queda empezar a trabajar.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#crear-un-proyecto",
    "href": "intro.html#crear-un-proyecto",
    "title": "1  Introducción",
    "section": "1.2 Crear un proyecto",
    "text": "1.2 Crear un proyecto\nJulia trae por defecto un gestor de paquetes propio. Esto nos ayuda a indicar las dependencias de nuestro código para que pueda ejecutarse en otros entornos de manera correcta.\nPodemos crear un primer proyecto indicando la activación del mismo.\n\nimport Pkg;\nPkg.activate(\".\")\n\nEsto generará dos ficheros esenciales para el correcto funcionamiento de nuestro código:\n\nProject.toml: Donde se listan las dependencias de nuestro proyecto.\nManifest.toml: Donde se indican las versiones de nuestro intérprete de Julia a utilizar, además de los hash de las versiones de los paquetes compatibles.\n\nPodemos ver las distintas opciones en la documentación oficial. Podemos añadir una dependencia mediante la función .add()\n\nPkg.add(\"Plots\")\n\nY esta se sumará a nuestros ficheros TOML. El comando .status() nos informará de las dependencias actuales.\n\nPkg.status()\n\n\nStatus `~/work/ciencia-datos-julia/ciencia-datos-julia/Project.toml`\n  [91a5bcdd] Plots v1.40.16\n\n\n\n\nDe forma que podemos hacer uso de esas librerías o paquetes en nuestro código.\n\nusing Plots\n\nplot(sin, \n     x-&gt;sin(2x), \n     0, \n     2π, \n     leg=false, \n     fill=(0,:lavender))\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigura 1.1: Gráfico paramétrico, mostrando un ejemplo de uso de librería/paquete\n\n\n\n\nEste es un aspecto clave ya que, tal y como sucede en Python, mucho de nuestro trabajo dependerá de los paquetes existentes y así no tendremos que reinventar la rueda una y otra vez.\n\n\n\n\nBezanson, Jeff, Alan Edelman, Stefan Karpinski, y Viral B Shah. 2017. «Julia: A fresh approach to numerical computing». SIAM review 59 (1): 65-98.\n\n\nLattner, Chris, y Vikram Adve. 2004. «LLVM: A compilation framework for lifelong program analysis & transformation». En International symposium on code generation and optimization, 2004. CGO 2004., 75-86. IEEE. https://llvm.org/pubs/2004-01-30-CGO-LLVM.pdf.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  Introducción",
    "section": "",
    "text": "Proceso de revisar y limpiar el código fuente de un programa para eliminar errores, mejorar su calidad y asegurar que cumpla con estándares de seguridad y eficiencia.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html",
    "href": "parts/firststeps/basics.html",
    "title": "2  Básicos de Julia",
    "section": "",
    "text": "2.1 Variables\nEn estos primeros ejemplos veremos los rudimentos de la sintaxis de Julia. Y empezaremos con los básicos aunque dado que existen amplias coincidencias entre Julia y Python, asumiendo que el lector conoce las estructuras base de Python (listas, diccionarios, etc..) nos centraremos en las grandes diferencias.\nVeamos con una de las primeras acciones que será la definición de variables.\nx = 2\n\n2\nComo vemos Julia tiene tipado dinámico, no tenemos por qué definir el tipo de datos asociado al valor que hemos introducido.\ntypeof(x)\n\nInt64\nPodemos hacer lo mismo con múltiples tipos\nx = 2 + 1im\ntypeof(x)\n\nComplex{Int64}\nAunque podemos incluir el tipado si fuera necesario.\ny::Float16 = 120\ntypeof(y)\n\nFloat16\nEsto impedirá que hagamos cosas como\ncon un error MethodError: Cannot convert an object of type String to an object of type Float16 en nuestro caso, ya que el tipo declarado de la variable y el valor a asociar no coinciden. Trabajaremos principalmente con los tipos habituales\nPodemos crear tipos específicos para nuestras necesidades basado en esos tipos básicos.\nstruct Usuario\n    nombre::String\n    apellido::String\n    anio_nacimiento::Int64\nend\n\nUsuario(\"Iraitz\",\"Montalbán\", 1984)\n\nUsuario(\"Iraitz\", \"Montalbán\", 1984)\nComo vemos , Julia tiene por costumbre imprimir el valor de la última línea ejecutada. Por definición son estructuras inmutables, por lo que si queremos variar sus datos una vez inicializados deberemos indicarlo expresamente.\nmutable struct UsuarioMutable\n    nombre::String\n    apellido::String\n    anio_nacimiento::Int64\nend\n\niraitz = UsuarioMutable(\"Iraitz\",\"Montalban\", 1984)\niraitz.apellido = \"Montalbán\"\n\n\"Montalbán\"\nLas variables booleanas nos permiten operaciones lógicas:\n!true\n\nfalse\ntrue && false\n\nfalse\nO de pertenencia a un grupo o tipo, igualdad == y desigualdad !=, &lt;, etc.\n6 isa Real\n\ntrue",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html#variables",
    "href": "parts/firststeps/basics.html#variables",
    "title": "2  Básicos de Julia",
    "section": "",
    "text": "y = \"hola\"\n\n\nEnteros: Int64\nNúmeros reales: Float64\nBinarios (verdadero o falso): Bool\nCadenas de caracteres: String\n\n\n\n\n\n\n\n!: NOT\n&&: AND\n||: OR",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html#arrays",
    "href": "parts/firststeps/basics.html#arrays",
    "title": "2  Básicos de Julia",
    "section": "2.2 Arrays",
    "text": "2.2 Arrays\nLas listas de datos funcionan de forma muy similar a las listas en Python.\n\na = [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\nVemos que el tipo por defecto se llama Vector{} y en corchetes marca nuestro tipo para los elementos. Esto implica que si un elemento requiere un tipado mayor, este se les asignará también al resto, siendo Any (cualquiera) la opción más general.\n\na = [1, 2, \"hola\"]\n\n3-element Vector{Any}:\n 1\n 2\n  \"hola\"\n\n\nPodemos separar en filas nuestros elementos y así generar un vector de dos dimensiones o matriz.\n\na = [1 2 3; 4 5 6]\n\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\nY podemos así extender a las dimensiones que necesitemos nuestros elementos multidimensionales. El acceso a los datos se realiza por índices o rangos, teniendo en cuenta el número de índices de nuestro vector. Quizás una de las cuestiones más relevantes viniendo de lenguajes como Python es que Julia cuenta lso elementos iniciando en 1 en lugar de 0. Por lo tanto pedir el elemento a[0] nos dará un error.\n\na[1]\n\n1\n\n\n\na[1:2]\n\n2-element Vector{Int64}:\n 1\n 4\n\n\n\na[:, 1:2]\n\n2×2 Matrix{Int64}:\n 1  2\n 4  5\n\n\n\na[2, 2]\n\n5\n\n\nTampoco funcionarán los índices negativos ya que deberemos usar la palabra reservada end.\n\na[end, end]\n\n6",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html#funciones",
    "href": "parts/firststeps/basics.html#funciones",
    "title": "2  Básicos de Julia",
    "section": "2.3 Funciones",
    "text": "2.3 Funciones\nOtro aspecto clave son las funciones. La lógica de nuestro programa que toma variables y devuelve variables basado en operaciones lógicas.\nfunction nombre_funcion(arg1, arg2)\n    resultado = hacemos cosas con arg1 y arg2\n    return resultado\nend\nTambién permite la definición mediate asignación, a modo de función lambda f_name(arg1, arg2) = hacemos cosas con arg1 y arg2 aunque por claridad emplearemos el modelo anterior.\nJulia permite especificar el tipo de argumentos haciendo que dos funciones con el mismo nombre apliquen distinta lógica en base a los argumentos de entrada y su tipo.\n\nfunction redondeo(x::Int64)\n    print(\"Es un entero\")\n    return x\nend\n\nfunction redondeo(x::Float64)\n    print(\"Es un número con decimales\")\n    return round(x)\nend\n\nmethods(redondeo)\n\n# 2 methods for generic function redondeo from \u001b[35mMain.Notebook\u001b[39m: redondeo(x::Float64) in Main.Notebook at /home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps/basics.qmd:157  redondeo(x::Int64) in Main.Notebook at /home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps/basics.qmd:152 \n\n\nEsto nos permite invocar a uno u otro únicamente en base al tipado.\n\nx = Float64(18)\n\nredondeo(x)\n\nEs un número con decimales\n\n\n18.0\n\n\nEn estos casos, si el tipado no coincide con ninguna de las definiciones de la función, Julia nos alertará con un error.\nPodemos también definir valores por defecto en los argumentos de entrada y devolver más de un elemento.\n\nfunction suma_y_multiplica(x::Int64, y::Int64 = 10)\n    suma = x + y\n    mult = x * y\n    return suma, mult\nend\n\nsuma_y_multiplica(5)\n\n(15, 50)\n\n\n\nsuma_y_multiplica(5, 5)\n\n(10, 25)\n\n\nEn caso de querer utilizar argumentos clave (keyword) estos se separan mediante el carácter ; y siempre deben disponer de un valor por defecto.\n\nfunction suma_y_multiplica(x::Int64; y::Int64 = 10)\n    suma = x + y\n    mult = x * y\n    return suma, mult\nend\n\nsuma_y_multiplica(5, y=7)\n\n(12, 35)\n\n\nPor último, en Julia existe la convención de añadir el carácter ! en caso de que la función altere o modifique alguno de sus argumentos.\n\nfunction suma_uno!(V)\n    for i in eachindex(V)\n        V[i] += 1\n    end\n    return nothing\nend\n\nsuma_uno! (generic function with 1 method)\n\n\nNo devolvemos nada pero si evaluamos el contenido de nuestro dato inicial, veremos que ha sido modificado.\n\ndatos = [1, 2, 3]\n\nsuma_uno!(datos)\n\ndatos\n\n3-element Vector{Int64}:\n 2\n 3\n 4\n\n\nExisten toda una serie de funciones que podemos emplear directamente desde la consola. Tenemos operadores básicos como suma o multiplicación, y otras funcionalidades no tan básicas como la selección de los primeros o últimos elementos de un vector, la creación de números aleatorios o el poder fijar una semilla para dicha generación aleatoria.\n\n2.3.1 Macros\nComo último apunte, veréis que existen sentencias que iniciamos con el carácter @. Estas son conocidas como macros, operaciones que nos permiten simplificar la sintaxis y que en muchos casos hacen referencia a funciones con el mismo nombre.\n\n@time print(\"Hemos tardado en imprimir esta línea\")\n\nHemos tardado en imprimir esta línea  0.000030 seconds (10 allocations: 64.281 KiB)\n\n\n\n\n\n\n\n\nMacro creada por nosotros\n\n\n\n\n\n\nmacro es_entero(x)\n   if typeof(x) == Int64  \n      return \"Es un entero\"\n   end\n   return \"No es un entero\"\nend\n\n@es_entero 5\n\n\"Es un entero\"\n\n\n\n\n\nMás que listar todas estas operaciones y estructuras disponibles, iremos viendo con ejemplos las más usuales según avancemos en los materiales.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/flujos.html",
    "href": "parts/firststeps/flujos.html",
    "title": "3  Flujos en Julia",
    "section": "",
    "text": "3.1 Condición (if)\nUna vez controlamos las estructuras base podremos aplicar distintas lógicas de flujo a la hora de evaluar nuestro código.\nLos flujos if muestran un funcionamiento similar a otros lenguajes de programación.\nLa sentencia debe iniciar con if y terminar con end. Internamente podemos evaluar condiciones adicionales con elseif o condiciones no contempladas con else.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Flujos en Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/flujos.html#condición-if",
    "href": "parts/firststeps/flujos.html#condición-if",
    "title": "3  Flujos en Julia",
    "section": "",
    "text": "a = 1\nb = 2\n\nif a &lt; b\n    \"a &lt; b\"\nelseif a &gt; b\n    \"a &gt; b\"\nelse\n    \"a == b\"\nend",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Flujos en Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/flujos.html#iteración-forwhile",
    "href": "parts/firststeps/flujos.html#iteración-forwhile",
    "title": "3  Flujos en Julia",
    "section": "3.2 Iteración (for/while)",
    "text": "3.2 Iteración (for/while)\nLos bucles nos permiten iterar durante un número definido de veces\nfor i in 1:3\n    # Hacer algo\nend\no bien, hasta que se cumpla una condición concreta. En este caso debemos indicar que i se trata de una variable global de forma que es accesible desde fuera del flujo (es decir, no local al bucle en curso).\ni = 0\n\nwhile i &lt; 3\n    # Hacer algo\n\n    # Esto es necesario para que salga del bucle\n    global i += 1\nend\nTambién podemos condicionar el bucle parando break o continuando a la siguiente iteración continue.\ni = 1;\n\nwhile true\n    println(i)\n    if i &gt;= 3\n        break\n    end\n    global i += 1\nend\nfor i = 1:10\n    if i % 3 != 0\n        continue\n    end\n    println(i)\nend\nMás detalle en Control flows.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Flujos en Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html",
    "href": "parts/firststeps/librerias.html",
    "title": "4  Módulos y librerías",
    "section": "",
    "text": "4.1 Fechas\nUn aspecto clave en los lenguajes de programación para ciencia de datos es el uso de librerías. Estas nos permiten atajar retos que otros ya han enfrentado y hacer uso de funciones ya creadas para el objeto.\nLa carga de módulos se hace mediante el comando using\nVeremos algunos módulos base que nos ayudarán con ciertas structuras de datos complejas de manejar.\nPara poder gestionar fechas deberemos importar un módulo específico\nusing Dates\nExisten dos tipos de fecha que deberemos manejar. Date para fechas sin tiempo informado\nDate(2025, 7, 3) # año, mes, dia\n\n2025-07-03\nY DateTime para fechas en las que dispongamos de hora.\nDateTime(2025, 7, 3, 12, 0) # año, mes, dia, hora, minutos\n\n2025-07-03T12:00:00\nPodremos también indicarlos basado en formato, como segundo argumento de nuestros dos tipos base.\nformat = DateFormat(\"yyyymmdd\")\nDate(\"19870913\", format)\n\n1987-09-13",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#fechas",
    "href": "parts/firststeps/librerias.html#fechas",
    "title": "4  Módulos y librerías",
    "section": "",
    "text": "Intervalos\nComo siempre con las fechas, podremos acceder a intervalos temporales (o periodos).\n\nfecha = Date(2025, 7, 1) \nperiodo = today() - fecha\n\n6 days\n\n\nPodemos ver que tipo soporta nuestra variable resultante.\n\ntypeof(periodo)\n\nDay\n\n\nLa función today() nos devuelve un Day por lo que si queremos más precisión, deberemos convertirlo a DateTime y usar now() en nuestra comparativa para que la resta sea entre los mismos tipos.\n\nfecha_hora_ms = DateTime(2025, 7, 1, 12, 1, 3, 120) # precisión de microsegundos \nlapso = now() - fecha_hora_ms\n\n518776710 milliseconds\n\n\n\ntypeof(lapso)\n\nMillisecond",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#descargas",
    "href": "parts/firststeps/librerias.html#descargas",
    "title": "4  Módulos y librerías",
    "section": "4.2 Descargas",
    "text": "4.2 Descargas\nExiste otro módulo que nos vendrá muy bien a la hora de descargarnos ficheros.\n\nusing Downloads\n\nPodremos indicarle a la función Downloads.download() la dirección desde la que descargar nuestro conjunto de datos.\n\nurl = \"https://raw.githubusercontent.com/IraitzM/ciencia-datos-julia/refs/heads/main/parts/firststeps/ejemplo.txt\"\n\nfichero_proyecto = Downloads.download(url) # creamos un fichero temporal\n\n\"/tmp/jl_z6xk9a3mj0\"\n\n\nY con funciones como readlines leer su contenido.\n\nreadlines(fichero_proyecto)\n\n1-element Vector{String}:\n \"Hola desde un fichero!\"\n\n\nVemos que devuelve una estructura de Vector con cadenas de texto (String) con el contenido del fichero.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#aleatorios",
    "href": "parts/firststeps/librerias.html#aleatorios",
    "title": "4  Módulos y librerías",
    "section": "4.3 Aleatorios",
    "text": "4.3 Aleatorios\nTrabajar con números aleatorios es habitual en ciencia de datos, y para ello podemos recurrir al módulo Random\n\nusing Random\n\nRandom.seed!(1234)\nRandom.randn()\n\n-0.3597289068234817",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#paquetes-habituales",
    "href": "parts/firststeps/librerias.html#paquetes-habituales",
    "title": "4  Módulos y librerías",
    "section": "4.4 Paquetes habituales",
    "text": "4.4 Paquetes habituales\nEn el caso de tratarse de módulos no disponibles como parte de la librería standard, deberemos recurrir al gestor de paquetes e instalarlas.\nusing Pkg;\nPkg.add(\"Libreria.jl\")\nTal y como veíamos en la introducción estos paquetes serán añadidos a los dos ficheros clave que nos permiten reproducir nuestro entorno en otra máquina.\nLas librerías que emplearemos en líneas generales son:\n\nManipulación de datos: DataFrames.jl y DataFramesMeta.jl\nVisualización: Plots.jl\n\nTodos estos paquetes y más están disponibles en https://juliapackages.com/.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/sistemaficheros.html",
    "href": "parts/firststeps/sistemaficheros.html",
    "title": "5  Sistema de ficheros",
    "section": "",
    "text": "Como en todo lenguaje de programación, deberemos gestionar la lectura y escritura de ficheros. El sistema de ficheros lo gestiona el sistema operativo de nuestra máquina con lo que se trata más bien de interactuar con este al menos de cara a conocer por ejemplo, dónde estamos ubicados.\n\ndirname(@__FILE__)\n\n\"/home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps\"\n\n\nPodemos crear carpetas de forma programática pero en la mayoría de casos se tratará de leer y escribir ficheros en rutas concretas. Para ello nos será útil la función joinpath que nos ayuda a conformar rutas tal y como el sistema de ficheros requiere.\n\nroot = dirname(@__FILE__)\njoinpath(root, \"ejemplo.txt\")\n\n\"/home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps/ejemplo.txt\"\n\n\nY como vimos anteriormente, usar la función readlines() para leer su contenido.\n\nfichero = joinpath(root, \"ejemplo.txt\")\nreadline(fichero)\n\n\"Hola desde un fichero!\"\n\n\nImaginemos por tanto que queremos descargarnos un CSV (Comma Separated Value) con información sobre los pasajeros del Titanic\n\nusing Downloads\n\nfichero_url = \"https://raw.githubusercontent.com/datasciencedojo/datasets/refs/heads/master/titanic.csv\"\nfichero = Downloads.download(fichero_url)\nreadlines(fichero)[:20]\n\n\"19,0,3,\\\"Vander Planke, Mrs. Julius (Emelia Maria Vandemoortele)\\\",female,31,1,0,345763,18,,S\"\n\n\nSi queremos conservar el fichero para más adelante podemos recurrir a la función write() y guardarlo donde nosotros queramos.\n\nwrite(\"../../data/titanic.csv\", read(fichero))\n\n60302\n\n\nY podemos revisar el contenido iterando sobre walkdir() que recorre los elementos de un directorio.\n\nitr = walkdir(\"../../data/\")\n(root, dirs, files) = first(itr)\n\n(\"../../data/\", String[], [\".gitkeep\", \"titanic.csv\", \"titanic.json\", \"titanic.parquet\"])\n\n\nDisponemos de los comandos más usuales a la hora de crear un directorio (mkdir()) o adentrarnos en él (cd()). Tenéis más detalle sobre los comandos disponibles aquí.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Sistema de ficheros</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html",
    "href": "parts/dataframes/basics.html",
    "title": "6  Cargando datos",
    "section": "",
    "text": "6.1 CSV\nYa conocemos las bases de Julia y ahora toca empezar a ver cómo hacer uso de los recursos más comunes en ciencia de datos. Dado que en el ejemplo anterior ya hemos creado un fichero con datos del Titanic, veamos si podemos cargarlo.\nQuizás uno de los formatos más comunes en el mundo empresarial es el fichero de texto con extensión CSV (Comma Separated Value). Extraído habitualmente de ficheros Excel o bien de exportaciones de sistemas gestores de base de datos, veremos que presenta un formato tabular donde cada celda viene separado por un carácter (siendo , o ; los más habituales); y el salto de línea marca el inicio de una nueva fila.\nDado que leer y trabajar con estos ficheros puede ser tedioso, recurriremos a uno de las primeras librerías que nos serán de ayuda en nuestra tarea.Dos en realidad, CSV que sabe como tratar estos ficheros y DataFrames que nos ofrece todas las funcionalidades de las estructuras tabulares.\nusing Pkg;\nPkg.add(\"CSV\")\nPkg.add(\"DataFrames\")\nusing CSV, DataFrames\n\ndf = CSV.read(joinpath(data_path,\"titanic.csv\"), DataFrame)\nfirst(df)\n\nDataFrameRow (12 columns)\n\n\n\nRow\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\nInt64\nInt64\nInt64\nString\nString7\nFloat64?\nInt64\nInt64\nString31\nFloat64\nString15?\nString1?\n\n\n\n\n1\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.25\nmissing\nS\nPodemos extender este uso sobre la carga de datos tabulares a otros formatos comunes como Excel gracias a librerías como XLSX.jl",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html#json",
    "href": "parts/dataframes/basics.html#json",
    "title": "6  Cargando datos",
    "section": "6.2 JSON",
    "text": "6.2 JSON\nOtro formato habitual, particularmente cuando trabajamos contra APIs es JSON. Necesitaremos entender las estructuras de estos documentos de cara a darles el formato tabular adecuado.\n\nreadlines(joinpath(data_path,\"titanic.json\"))\n\n20946-element Vector{String}:\n \"[\"\n \"  {\"\n \"    \\\"pclass\\\": 1,\"\n \"    \\\"survived\\\": 1,\"\n \"    \\\"name\\\": \\\"Allen, Miss. Elisabeth Walton\\\",\"\n \"    \\\"sex\\\": \\\"female\\\",\"\n \"    \\\"age\\\": 29,\"\n \"    \\\"sibsp\\\": 0,\"\n \"    \\\"parch\\\": 0,\"\n \"    \\\"ticket\\\": 24160,\"\n ⋮\n \"    \\\"ticket\\\": 315082,\"\n \"    \\\"fare\\\": 7.875,\"\n \"    \\\"cabin\\\": \\\"\\\",\"\n \"    \\\"embarked\\\": \\\"S\\\",\"\n \"    \\\"boat\\\": \\\"\\\",\"\n \"    \\\"body\\\": \\\"\\\",\"\n \"    \\\"home.dest\\\": \\\"\\\"\"\n \"  }\"\n \"]\"\n\n\nPodemos ver que en este caso disponemos de una lista de objetos con un único nivel de datos que podemos trasladar directamente a un DataFrame.\n\nusing Pkg;\nPkg.add(\"JSON\")\n\n\nusing JSON, DataFrames\n\n# Leemos las lineas y las juntamos en una cadena única\ndata = join(readlines(joinpath(data_path,\"titanic.json\")))\n\ndf = DataFrame(JSON.parse(data))\nfirst(df)\n\nDataFrameRow (14 columns)\n\n\n\nRow\nsex\nage\nparch\nboat\nname\nhome.dest\ncabin\nfare\nembarked\nbody\nsibsp\npclass\nsurvived\nticket\n\n\n\nString\nAny\nInt64\nAny\nString\nString\nString\nAny\nString\nAny\nInt64\nInt64\nInt64\nAny\n\n\n\n\n1\nfemale\n29.0\n0\n2\nAllen, Miss. Elisabeth Walton\nSt Louis, MO\nB5\n211.338\nS\n\n0\n1\n1\n24160\n\n\n\n\n\n\nEs importante prestar atención a la estructura del JSON ya que si dispone de múltiples anidamientos y objetos complejos será difícil disponer de una estructura tabular plana directamente sin necesitar trabajo de preprocesado y aplanado previo.",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html#parquet",
    "href": "parts/dataframes/basics.html#parquet",
    "title": "6  Cargando datos",
    "section": "6.3 Parquet",
    "text": "6.3 Parquet\nSi hay un formato omnipresente desde que fue creado allá por 2013 es Parquet. Formato columnar y comprimido por defecto, permite trabajar con estructuras de datos tabulares de forma eficiente para los procesos analíticos, con una huella de almacenamiento mínima y compatible con multitud de las herramientas de stack de ciencia de datos. De hecho, es la base para estructuras de almacenamiento más complejas que ofrecen capacidades ACID como Iceberg o Delta Lake.\n\nusing Pkg;\nPkg.add(\"Parquet\")\n\nPodemos cargar el contenido directamente como DataFrame gracias a la compatibilidad entre estas dos librerías.\n\nusing Parquet, DataFrames\n\ndf = DataFrame(read_parquet(joinpath(data_path,\"titanic.parquet\")))\nfirst(df)\n\nDataFrameRow (7 columns)\n\n\n\nRow\nSurvived\nPclass\nSex\nAge\nSibSp\nParch\nFare\n\n\n\nBool?\nString?\nString?\nFloat64?\nInt64?\nInt64?\nFloat64?\n\n\n\n\n1\nfalse\n3\nmale\n22.0\n1\n0\n7.25\n\n\n\n\n\n\nExisten otras dos grandes fuentes con las que será necesario interactuar para formar nuestro elenco de opciones.",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html#apis",
    "href": "parts/dataframes/basics.html#apis",
    "title": "6  Cargando datos",
    "section": "6.4 APIs",
    "text": "6.4 APIs\nInteractuar con APIs requiere realizar consultas siguiendo el protocolo HTTP y obtener los datos de respuesta en un formato compatible. En nuestro caso, al haber visto como el formato JSON es manejable gracias a la librería de Julia, simplemente deberemos añadir librerías de manejo del protocolo en concreto.\n\nusing Pkg;\nPkg.add(\"HTTP\")\n\n\nusing HTTP\nusing JSON\n\n# Dirección para el echo de postman\nurl=\"https://postman-echo.com/get?foo1=bar1&foo2=bar2\"\n\nrespuesta = HTTP.get(url)\ntexto_respuesta = String(respuesta.body)\nJSON.parse(texto_respuesta)[\"args\"]\n\nDict{String, Any} with 2 entries:\n  \"foo1\" =&gt; \"bar1\"\n  \"foo2\" =&gt; \"bar2\"\n\n\nPodéis probar con otras APIs donde poder cargar los datos directamente en un DataFrame. Tomemos como ejemplo la PokeAPI\n\nusing HTTP\nusing JSON\n\n# Dirección para el echo de postman\nurl=\"https://pokeapi.co/api/v2/pokemon?limit=10\"\n\nrespuesta = HTTP.get(url)\ntexto_respuesta = String(respuesta.body)\n\ndf = DataFrame(JSON.parse(texto_respuesta)[\"results\"])\nfirst(df, 5)\n\n5×2 DataFrame\n\n\n\nRow\nname\nurl\n\n\n\nString\nString\n\n\n\n\n1\nbulbasaur\nhttps://pokeapi.co/api/v2/pokemon/1/\n\n\n2\nivysaur\nhttps://pokeapi.co/api/v2/pokemon/2/\n\n\n3\nvenusaur\nhttps://pokeapi.co/api/v2/pokemon/3/\n\n\n4\ncharmander\nhttps://pokeapi.co/api/v2/pokemon/4/\n\n\n5\ncharmeleon\nhttps://pokeapi.co/api/v2/pokemon/5/",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html#sistemas-gestores-de-base-de-datos",
    "href": "parts/dataframes/basics.html#sistemas-gestores-de-base-de-datos",
    "title": "6  Cargando datos",
    "section": "6.5 Sistemas gestores de Base de Datos",
    "text": "6.5 Sistemas gestores de Base de Datos\nLos sistemas gestores de base de datos son un recurso habitual donde deberemos de encontrar el modo de poder enviar nuestras consultas (empleando SQL) y obtener una estructura que encaje en nuestros DataFrames.\nPara la mayoría de casos deberemos encontrar la librería compatible con nuestra base de datos dado que la especificación de cada una puede variar y requeriremos cierta librería en cada caso.\n\nSQLite\nDuckDB\nMySQL\nPostgreSQL\n\nY más que podéis encontrar en https://juliapackages.com/c/database.\n\nusing Pkg;\nPkg.add(\"DuckDB\")\n\n\nusing DuckDB\n\ncon_duckdb = DBInterface.connect(DuckDB.DB, \"bd.duckdb\")\n\nDuckDB.DB(\"bd.duckdb\")\n\n\nUna vez conectados podemos leer de los datos del entorno.\n\n# Creamos una serie de datos aleatorios\nlen = 10_000\ndatos = (a = collect(1:len), b = rand(1:100, len))\n\n# Create la tabla\ncreate_query = \"\nCREATE TABLE IF NOT EXISTS data(\n  a INT NOT NULL,\n  b INT NOT NULL\n);\"\nDBInterface.execute(con_duckdb, create_query);\n\nInsertamos los datos de prueba.\n\n\n\n\n\n\nTip\n\n\n\nCon @time podemos ver el tiempo que le toma realizar la tarea en cuestión.\n\n\n\n# Escribimos los datos\nstr = join(repeat('?', length(datos)), ',')\nwrite_query = DBInterface.prepare(con_duckdb, \"INSERT INTO data VALUES($str)\")\n@time DBInterface.executemany(write_query, datos)\n\n  2.228166 seconds (185.07 k allocations: 7.969 MiB, 2.24% compilation time)\n\n\nY podemos proceder a leer parte de estos.\n\n@time table_rd = DBInterface.execute(con_duckdb, \"SELECT * FROM data\")\n\n  0.000574 seconds (18 allocations: 640 bytes)\n\n\n(a = Int32[1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  9991, 9992, 9993, 9994, 9995, 9996, 9997, 9998, 9999, 10000], b = Int32[29, 92, 34, 59, 61, 23, 15, 74, 27, 88  …  21, 4, 38, 13, 33, 90, 79, 49, 19, 34])\n\n\nLa lectura puede realizarse directamente formando el DataFrame resultante a utilizar ya que las bases de datos relacionales siempre nos retornan estructuras tabulares.\n\ndf = DataFrame(DBInterface.execute(con_duckdb, \"SELECT * FROM data\"))\nfirst(df, 5)\n\n5×2 DataFrame\n\n\n\nRow\na\nb\n\n\n\nInt32\nInt32\n\n\n\n\n1\n1\n29\n\n\n2\n2\n92\n\n\n3\n3\n34\n\n\n4\n4\n59\n\n\n5\n5\n61\n\n\n\n\n\n\nSiempre deberemos de acordarnos de cerrar la conexión una vez que hayamos obtenido los datos de la fuente.\n\nDBInterface.close!(con_duckdb)",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/summary.html",
    "href": "parts/dataframes/summary.html",
    "title": "7  Análisis preliminar",
    "section": "",
    "text": "7.1 Selección de campos\nPartimos de nuestros datos ya cargados, y deberemos ver la estructura base de nuestro dataframe. La función describe nos ofrece una primera revisión de los datos indicando nombre de las columnas, estadísticas de la distribución de datos, valores faltantes y typo de dato.\nA esto podemos unirle conocer el tamaño de nuestro conjunto mediante el método size.\nDeberemos entender la naturaleza de los datos que nos muestran y conocer, entre otras cuestiones:\nEsto nos obliga a explorar si son variables categóricas codificadas con números, si existen campos con una granularidad alta o con valor constante. Podemos pedir estadísticas concretas al método describe.\nPodemos por tanto descartar aquellos casos donde el grano de detalle es prácticamente individual.\ncampos_a_descartar = [:Ticket, :Name]\n\n2-element Vector{Symbol}:\n :Ticket\n :Name\nVemos que únicamente a contemplado los casos donde nos encontramos con tipos String. Pero sabemos, por ejemplo, que la columna Survived es una condición booleana de si sobrevivieron o no. Emplearemos la propia función de conversión de cada tipo, añadiéndole un . al final que denote por fila. En Julia, el punto (.) al final de una función o nombre de tipo (como string.) indica broadcasting, lo que aplicar una función elemento por elemento a lo largo de un array o colección, sin necesidad de escribir un bucle explícito.\nAl igual que antes, empleamos el indicador ! ya que vamos a modificar la columna en su sitio. En Julia:\ndf[!,:Survived] = Bool.(df[!,:Survived])\ndf[!,:PassengerId] = string.(df[!,:PassengerId])\ndf[!,:Pclass] = string.(df[!,:Pclass]);\nGracias a la librería Query.jl podemos emplear una sintaxis más compacta en nuestras consultas, añadiendo etapas de transformación como en los pipelines habituales en R o Python.\nusing Pkg;\nPkg.add(\"Query\")\nusing DataFrames, Query\n\ncampos = [:Survived, :PassengerId, :Pclass]\n\nfilas = nrow(df)\n\nfor col in campos\n    únicos = df |&gt; \n        @select({Symbol(col) = _.col}) |&gt; collect |&gt; x -&gt; unique(df[!, col])\n    println(\"Columna $col tiene $(length(únicos)) valores únicos en $(filas) filas.\")\n    println()\nend\n\nColumna Survived tiene 2 valores únicos en 891 filas.\n\nColumna PassengerId tiene 891 valores únicos en 891 filas.\n\nColumna Pclass tiene 3 valores únicos en 891 filas.\nTenemos varios puntos en el código anterior:\nHemos dado un salto en este bloque así que tomaros tiempo para entender cada parte. De aquí concluimos que la columna PassengerId no será muy relevante en el análisis estadístico ya que muestra un grano muy fino de valores que únicamente permiten identificar a cada individuo de nuestro conjunto. Pasará algo muy similar con valores de texto que indiquen nombre o ticket. Este dato ya lo obtuvimos anteriormente con lo que podemos determinar que las columnas de interés en adelante serán\nappend!(campos_a_descartar, [:PassengerId])\nselect!(df, Not(campos_a_descartar));\nRecordad que ! modifica el dato objeto\nfirst(df, 5)\n\n5×9 DataFrame\n\n\n\nRow\nSurvived\nPclass\nSex\nAge\nSibSp\nParch\nFare\nCabin\nEmbarked\n\n\n\nBool\nString\nString7\nFloat64?\nInt64\nInt64\nFloat64\nString15?\nString1?\n\n\n\n\n1\nfalse\n3\nmale\n22.0\n1\n0\n7.25\nmissing\nS\n\n\n2\ntrue\n1\nfemale\n38.0\n1\n0\n71.2833\nC85\nC\n\n\n3\ntrue\n3\nfemale\n26.0\n0\n0\n7.925\nmissing\nS\n\n\n4\ntrue\n1\nfemale\n35.0\n1\n0\n53.1\nC123\nS\n\n\n5\nfalse\n3\nmale\n35.0\n0\n0\n8.05\nmissing\nS",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis preliminar</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/summary.html#selección-de-campos",
    "href": "parts/dataframes/summary.html#selección-de-campos",
    "title": "7  Análisis preliminar",
    "section": "",
    "text": "df[:, :Columna] devuelve una copia de la columna. Si modificas el resultado, el DataFrame original no cambia.\ndf[!, :Columna] devuelve una referencia a la columna original. Si modificas el resultado, el DataFrame original sí cambia.\n\n\n\n\n\n\n\n\nNota\n\n\n\nEl carácter final ; s simplemente para que no imprima el resultado por pantalla cuando se emplean Notebooks o scripts the Quarto .qmd.\n\n\n\n\n\n\n\n@select es una macro para seleccionar columnas de un DataFrame. {Symbol(col) = _.col} crea un diccionario o mapeo donde la clave es el símbolo de la variable col y el valor es la columna correspondiente en el DataFrame. Symbol(col)en sí convierte el nombre de la columna (probablemente un string) en un símbolo, que es un tipo de dato común en Julia para referirse a nombres de columnas.\n|&gt; es el operador “pipe” en Julia, que pasa el resultado de la expresión anterior como argumento a la función siguiente.\ncollect toma un iterable (como el resultado de (select?)) y lo convierte en una colección concreta, como un array.\nx -&gt; unique(df[!, col]) es una función anónima (sin nombre designado como en el caso de las lambda) que toma x (aunque aquí no se usa directamente) y devuelve los valores únicos de la columna col del DataFrame df.\n\n\n\n\n\n\n\n\n\n\n\nFrameworks de manipulación\n\n\n\n\n\nTenéis más información en DataFrames.jl &gt; Querying frameworks",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis preliminar</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/summary.html#valores-numéricos",
    "href": "parts/dataframes/summary.html#valores-numéricos",
    "title": "7  Análisis preliminar",
    "section": "7.2 Valores numéricos",
    "text": "7.2 Valores numéricos\nUna de las mejores formes de conocer las distribuciones de datos es precisamente visualizando su histograma o gráfico de densidad. Deberéis instalar los paquetes de visualización pertinentes.\n\nPkg.add(\"StatsPlots\")\n\n\nusing StatsPlots\n\nhistogram(df.Age, normalize=true)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVemos que si lo comparamos con una distribución normal, las gráficas difieren bastante. Esto suele requerir de evaluar la normalidad de la\n\n\n\n\n\n\nGráfico de distribución normal\n\n\n\n\n\n\nPkg.add(\"Distributions\")\n\n\nusing Distributions\n#| output: collapse\n\nplot(Normal(3, 5), lw=3)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEl primer reto al que nos enfrentaremos será el de poder mostrar el diagrama de densidad, ya que no permite la existencia de valores faltantes. Y como podemos ver existen varios para la columna age. Deberemos aprender a filtrar en base a una condición.\n\n7.2.1 Valores faltantes\nEn el caso de Julia missing es un tipo de datos especial que no indica el valor faltante en una celda.\n\ntypeof(missing)\n\nMissing\n\n\nExisten funciones específicas para eliminar o simplemente filtrar (filter) en base a la condición de dato faltante (ismissing). En este caso podremos ver los primeros tres elementos en nuestro dataframe donde se cumple la condición de dato faltante en el campo edad (:Age).\n\nfirst(\n    filter(\n        :Age =&gt; ismissing, df\n    ),\n    3 # mostramos los primeros tres elementos\n)\n\n3×9 DataFrame\n\n\n\nRow\nSurvived\nPclass\nSex\nAge\nSibSp\nParch\nFare\nCabin\nEmbarked\n\n\n\nBool\nString\nString7\nFloat64?\nInt64\nInt64\nFloat64\nString15?\nString1?\n\n\n\n\n1\nfalse\n3\nmale\nmissing\n0\n0\n8.4583\nmissing\nQ\n\n\n2\ntrue\n2\nmale\nmissing\n0\n0\n13.0\nmissing\nS\n\n\n3\ntrue\n3\nfemale\nmissing\n0\n0\n7.225\nmissing\nC\n\n\n\n\n\n\nY así podemos ver la densidad indicando nuestro dataframe modificado para que no cumpla esta condición. StatsPlots nos da la opción de explorar otras macros (ya vimos la macro de @time) que en este caso será el turno de @df. Esta macro, empleada con la sintaxis\n@df &lt;tabla&gt; &lt;función de visualización&gt;\nnos permite definir una estructura tabular que luego será empleada en la función de visualización a la que solo deberemos indicarle en qué columnas centrarse.\n\n@df filter(:Age =&gt; !ismissing, df) density(:Age)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComo vemos, la función de densidad nos presenta un perímetro continuo sobre el histograma anterior. Podemos evaluar la normalidad de nuestra columna empleando tests estadísticos. La librería HypothesisTests.jl nos dará buenas referencias de cuales podemos usar.\nPor simplificar de momento, viendo que la media y la mediana muestra valores parejos para el intervalo de datos, asumiremos dicha normalidad y veremos como imputar la media como valor estimado a los datos faltantes de nuestro dataframe.\n\nusing Statistics\n\nmean(skipmissing(df.Age))\n\n29.69911764705882\n\n\nEste valor lo reemplazaremos indicando que queremos transformar (alterando el objeto df)\n\ntransform!(df, :Age =&gt; ByRow(x -&gt; coalesce(x, mean(skipmissing(df.Age)))); renamecols=false)\ndescribe(df)\n\n9×7 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\nnmissing\neltype\n\n\n\nSymbol\nUnion…\nAny\nUnion…\nAny\nInt64\nType\n\n\n\n\n1\nSurvived\n0.383838\nfalse\n0.0\ntrue\n0\nBool\n\n\n2\nPclass\n\n1\n\n3\n0\nString\n\n\n3\nSex\n\nfemale\n\nmale\n0\nString7\n\n\n4\nAge\n29.6991\n0.42\n29.6991\n80.0\n0\nFloat64\n\n\n5\nSibSp\n0.523008\n0\n0.0\n8\n0\nInt64\n\n\n6\nParch\n0.381594\n0\n0.0\n6\n0\nInt64\n\n\n7\nFare\n32.2042\n0.0\n14.4542\n512.329\n0\nFloat64\n\n\n8\nCabin\n\nA10\n\nT\n687\nUnion{Missing, String15}\n\n\n9\nEmbarked\n\nC\n\nS\n2\nUnion{Missing, String1}\n\n\n\n\n\n\nTras esto, con las dos columnas restantes podemos optar por eliminar estos datos. dropmissing eliminará las filas que contengan valores faltantes en sus celdas.\n\ndf_sinfilas = dropmissing(df)\nsize(df_sinfilas)\n\n(202, 9)\n\n\nO mediante la función select podemos indicarle que no queremos las columnas con datos faltantes. Para esta macro deberemos usar otro paquete muy habitual para este tipo de labores.\n\nPkg.add(\"DataFramesMeta\")\n\n\nusing DataFramesMeta\n\nselect!(df, Not(:Cabin, :Embarked))\ndescribe(df)\n\nWARNING: using DataFramesMeta.@select in module Notebook conflicts with an existing identifier.\n\n\n7×7 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\nnmissing\neltype\n\n\n\nSymbol\nUnion…\nAny\nUnion…\nAny\nInt64\nDataType\n\n\n\n\n1\nSurvived\n0.383838\nfalse\n0.0\ntrue\n0\nBool\n\n\n2\nPclass\n\n1\n\n3\n0\nString\n\n\n3\nSex\n\nfemale\n\nmale\n0\nString7\n\n\n4\nAge\n29.6991\n0.42\n29.6991\n80.0\n0\nFloat64\n\n\n5\nSibSp\n0.523008\n0\n0.0\n8\n0\nInt64\n\n\n6\nParch\n0.381594\n0\n0.0\n6\n0\nInt64\n\n\n7\nFare\n32.2042\n0.0\n14.4542\n512.329\n0\nFloat64",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis preliminar</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/summary.html#variables-categóricas",
    "href": "parts/dataframes/summary.html#variables-categóricas",
    "title": "7  Análisis preliminar",
    "section": "7.3 Variables categóricas",
    "text": "7.3 Variables categóricas\nLas variables categóricas son un tipo especial de variable que se utiliza para representar datos que pueden tomar un número limitado de valores distintos, llamados categorías o niveles.\nEn Julia, las variables categóricas se manejan principalmente usando el paquete CategoricalArrays.jl. Este paquete proporciona el tipo CategoricalArray, que permite almacenar datos categóricos de manera eficiente y realizar operaciones como ordenamiento, agrupamiento y comparación entre categorías.\nEn nuestro caso, la columna Pclass muestra categorías de prioridad de los pasajeros que encajarían dentro de la descripción de niveles.\n\nPkg.add(\"CategoricalArrays\")\n\n\nusing CategoricalArrays\n\n# Creamos una copia del dataframe\ndf_cat = copy(df)\n\n# Primero, reemplazamos los valores numéricos por los nombres de nivel deseados\ndf_cat[!, :Pclass] = replace(df_cat[!, :Pclass], \"1\" =&gt; \"Primera\", \"2\" =&gt; \"Segunda\", \"3\" =&gt; \"Tercera\")\n\n# Luego, convertimos la columna a categórica con los niveles y orden deseado\nlevels = [\"Tercera\", \"Segunda\", \"Primera\"]\ndf_cat[!, :Pclass] = categorical(df_cat[!, :Pclass]; levels, ordered=true)\n\n# Y comprobamos el resultado\ndescribe(df_cat)\n\n7×7 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\nnmissing\neltype\n\n\n\nSymbol\nUnion…\nAny\nUnion…\nAny\nInt64\nDataType\n\n\n\n\n1\nSurvived\n0.383838\nfalse\n0.0\ntrue\n0\nBool\n\n\n2\nPclass\n\nTercera\n\nPrimera\n0\nCategoricalValue{String, UInt32}\n\n\n3\nSex\n\nfemale\n\nmale\n0\nString7\n\n\n4\nAge\n29.6991\n0.42\n29.6991\n80.0\n0\nFloat64\n\n\n5\nSibSp\n0.523008\n0\n0.0\n8\n0\nInt64\n\n\n6\nParch\n0.381594\n0\n0.0\n6\n0\nInt64\n\n\n7\nFare\n32.2042\n0.0\n14.4542\n512.329\n0\nFloat64\n\n\n\n\n\n\nGracias a ser categóricas ordenadas, podemos realizar comparativas como si de números se tratara pero empleando una sintaxis que nos aporta cierta claridad semántica. Si ordenamos de forma ascendente vemos que los viajeros en Tercera están en una categoría inferior a los de Primera.\n\nfirst(sort(df_cat, :Pclass), 3)\n\n3×7 DataFrame\n\n\n\nRow\nSurvived\nPclass\nSex\nAge\nSibSp\nParch\nFare\n\n\n\nBool\nCat…\nString7\nFloat64\nInt64\nInt64\nFloat64\n\n\n\n\n1\nfalse\nTercera\nmale\n22.0\n1\n0\n7.25\n\n\n2\ntrue\nTercera\nfemale\n26.0\n0\n0\n7.925\n\n\n3\nfalse\nTercera\nmale\n35.0\n0\n0\n8.05\n\n\n\n\n\n\n\nlast(sort(df_cat, :Pclass), 3)\n\n3×7 DataFrame\n\n\n\nRow\nSurvived\nPclass\nSex\nAge\nSibSp\nParch\nFare\n\n\n\nBool\nCat…\nString7\nFloat64\nInt64\nInt64\nFloat64\n\n\n\n\n1\ntrue\nPrimera\nfemale\n56.0\n0\n1\n83.1583\n\n\n2\ntrue\nPrimera\nfemale\n19.0\n0\n0\n30.0\n\n\n3\ntrue\nPrimera\nmale\n26.0\n0\n0\n30.0\n\n\n\n\n\n\nCosa que no podríamos hacer con el uso de cadenas de texto.\n\n\"Primera\" &lt; \"Tercera\"\n\ntrue\n\n\nYa tenemos un conjunto de datos algo más limpio. Ahora toca estudiarlo en profundidad. Si queremos guardarlo para más adelante podemos volcar el DataFrame a fichero aunque si lo volcamos a un CSV o fichero de texto podemos perder la información categórica. De hecho, muchos formatos y entornos no serán compatibles con esta tipología de dato concreta.\n\nusing Parquet\n\ndf[!,:Sex] = String.(df[!,:Sex]);\n\nwrite_parquet(joinpath(data_path,\"titanic.parquet\"), df)\n\n4",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis preliminar</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/exploratory.html",
    "href": "parts/dataframes/exploratory.html",
    "title": "8  Análisis exploratorio",
    "section": "",
    "text": "8.1 Balance de muestras\nTras haber trabajado con nuestros datos originales, ya disponemos de unos datos limpios, sin datos faltantes y con cierta carga informativa.\nAhora procederemos a explorar las distribuciones de datos y estadísticas de las categorías pertinentes.\nNecesitamos evaluar si existen categoría mayoritarias en nuestro conjunto de datos. StatsBase nos ofrece la función countmap que directamente nos dará las ocurrencias de cada opción en las columnas como clave y valor de un diccionario.\nimport Pkg\n\nPkg.add(\"StatsBase\")\nusing StatsBase\n\ncountmap(df[:,:Survived])\n\nDict{Union{Missing, Bool}, Int64} with 2 entries:\n  0 =&gt; 549\n  1 =&gt; 342\nY con StatsPlots podremos visualizar un gráfico de barras de cara a comparar los valores.\nusing StatsPlots\n\n# Conteo de ocurrencias\nconteo = countmap(df[:,:Survived])\n\n# Convertir a porcentajes\ntotal = sum(values(conteo))\nporcentajes = Dict(k =&gt; v/total*100 for (k,v) in conteo)\n\n# Etiquetas según los valores de Survived\netiquetas = [\"No sobrevivió\", \"Sobrevivió\"]\n# Ordenar los porcentajes según etiquetas (asumiendo false = No sobrevivió, true = Sobrevivió)\nvalores = [get(porcentajes, false, 0.0), get(porcentajes, true, 0.0)]\n\n# Graficar\nbar(\n    etiquetas,\n    valores,\n    legend=false,\n    ylabel=\"Porcentaje (%)\",\n    xlabel=\"Survived\", \n    title=\"Porcentaje de supervivientes\"\n)\nVemos que un porcentaje superior de pasajeros (61%) no sobrevivió al Titanic.",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Análisis exploratorio</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/exploratory.html#distribución-de-datos",
    "href": "parts/dataframes/exploratory.html#distribución-de-datos",
    "title": "8  Análisis exploratorio",
    "section": "8.2 Distribución de datos",
    "text": "8.2 Distribución de datos\nPodemos querer analizar si estas dos poblaciones muestran características significativas entre sí. Algo que permita distinguir a los dos conjuntos de datos de forma significativa.\n\n8.2.1 Numérica (edad)\n\n@df df violin(\n    :Survived,\n    :Age,\n    legend=false,\n    ylabel=\"Edad\",\n    xlabel=\"Supervivencia\",\n    title=\"Distribución de edad según supervivencia\",\n    xticks=([false, true], [\"No sobrevivió\", \"Sobrevivió\"])\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSe observa que en el espectro más bajo de edad el conjunto de viajeros que sobrevivió es algo superior.\n\n\n8.2.2 Categórica (sexo)\n\nusing StatsPlots\n\n# Filtrar por supervivientes y no supervivientes\ndf_no = filter(:Survived =&gt; x -&gt; x == false, df)\ndf_si = filter(:Survived =&gt; x -&gt; x == true, df)\n\n# Conteo por sexo en cada grupo\nconteo_no = countmap(df_no[:, :Sex])\nconteo_si = countmap(df_si[:, :Sex])\n\n# Etiquetas y valores\netiquetas_sexo = [\"Hombre\", \"Mujer\"]\nvalores_no = [get(conteo_no, \"male\", 0), get(conteo_no, \"female\", 0)]\nvalores_si = [get(conteo_si, \"male\", 0), get(conteo_si, \"female\", 0)]\n\n# Dibujar dos gráficas en paralelo\nplot(\n    bar(etiquetas_sexo, valores_no, title=\"No sobrevivió\", legend=false, ylabel=\"Cantidad\", xlabel=\"Sexo\"),\n    bar(etiquetas_sexo, valores_si, title=\"Sobrevivió\", legend=false, ylabel=\"Cantidad\", xlabel=\"Sexo\"),\n    layout=(1,2)\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVaya, aquí si que vemos dos extremos importantes. De los que sobrevivieron existe un desbalance positivo con respecto a las mujeres frente al caso de no superviviencia, donde la población de hombres fue mucho más significativa.\nPosiblemente si añadieramos un eje adicional con respecto a la clase, veríamos cómo esta última característica afecta significativamente a la probabilidad de supervivencia.\n\n\n8.2.3 De dispersión (sexo y clase)\n\nusing DataFrames, StatsPlots\n\n# Agrupar por clase y sexo, calcular tasa de supervivencia\ndf_group = combine(groupby(df, [:Pclass, :Sex]), :Survived =&gt; mean =&gt; :SurvivalRate)\n\n# Convertir Sex a string para etiquetas\ndf_group.Sex = string.(df_group.Sex)\n\n# Crear etiquetas combinadas para el eje x\ndf_group.label = string.(df_group.Pclass, \" - \", df_group.Sex)\n\n# Graficar barras agrupadas\n@df df_group bar(\n    :label,\n    :SurvivalRate,\n    group = :Sex,\n    ylabel = \"Tasa de supervivencia\",\n    legend = :topright,\n    title = \"Tasa de supervivencia por clase y sexo\",\n    bar_position = :dodge,\n    ylim = (0,1),\n    xrotation = 45\n)\n\n\n┌ Warning: Keyword argument bar_position not supported with Plots.GRBackend().  Choose from: annotationcolor, annotationfontfamily, annotationfontsize, annotationhalign, annotationrotation, annotations, annotationvalign, arrow, aspect_ratio, axis, background_color, background_color_inside, background_color_outside, background_color_subplot, bar_width, bins, bottom_margin, camera, clims, color_palette, colorbar, colorbar_entry, colorbar_scale, colorbar_title, colorbar_titlefont, colorbar_titlefontcolor, colorbar_titlefontrotation, colorbar_titlefontsize, connections, contour_labels, discrete_values, fill, fill_z, fillalpha, fillcolor, fillrange, fillstyle, flip, fontfamily, fontfamily_subplot, foreground_color, foreground_color_axis, foreground_color_border, foreground_color_grid, foreground_color_subplot, foreground_color_text, formatter, framestyle, grid, gridalpha, gridlinewidth, gridstyle, group, guide, guidefont, guidefontcolor, guidefontfamily, guidefonthalign, guidefontrotation, guidefontsize, guidefontvalign, html_output_format, inset_subplots, label, layout, left_margin, legend_background_color, legend_column, legend_font, legend_font_color, legend_font_family, legend_font_halign, legend_font_pointsize, legend_font_rotation, legend_font_valign, legend_foreground_color, legend_position, legend_title, legend_title_font_color, legend_title_font_family, legend_title_font_pointsize, legend_title_font_rotation, legend_title_font_valigm, levels, lims, line, line_z, linealpha, linecolor, linestyle, linewidth, link, margin, marker_z, markeralpha, markercolor, markershape, markersize, markerstrokealpha, markerstrokecolor, markerstrokewidth, minorgrid, minorgridalpha, minorgridlinewidth, minorgridstyle, minorticks, mirror, normalize, orientation, overwrite_figure, permute, plot_title, plot_titlefontcolor, plot_titlefontfamily, plot_titlefontrotation, plot_titlefontsize, plot_titlelocation, plot_titlevspan, polar, primary, projection, quiver, ribbon, right_margin, rotation, scale, series_annotations, seriesalpha, seriescolor, seriestype, show, show_empty_bins, showaxis, size, smooth, subplot, subplot_index, thickness_scaling, tick_direction, tickfontcolor, tickfontfamily, tickfonthalign, tickfontrotation, tickfontsize, tickfontvalign, ticks, title, titlefontcolor, titlefontfamily, titlefonthalign, titlefontrotation, titlefontsize, titlefontvalign, top_margin, unitformat, weights, widen, window_title, x, xdiscrete_values, xerror, xflip, xforeground_color_axis, xforeground_color_border, xforeground_color_grid, xforeground_color_text, xformatter, xgrid, xgridalpha, xgridlinewidth, xgridstyle, xguide, xguidefontcolor, xguidefontfamily, xguidefonthalign, xguidefontrotation, xguidefontsize, xguidefontvalign, xlims, xlink, xminorgrid, xminorgridalpha, xminorgridlinewidth, xminorgridstyle, xminorticks, xmirror, xrotation, xscale, xshowaxis, xtick_direction, xtickfontcolor, xtickfontfamily, xtickfonthalign, xtickfontrotation, xtickfontsize, xtickfontvalign, xticks, xunitformat, xwiden, y, ydiscrete_values, yerror, yflip, yforeground_color_axis, yforeground_color_border, yforeground_color_grid, yforeground_color_text, yformatter, ygrid, ygridalpha, ygridlinewidth, ygridstyle, yguide, yguidefontcolor, yguidefontfamily, yguidefonthalign, yguidefontrotation, yguidefontsize, yguidefontvalign, ylims, ylink, yminorgrid, yminorgridalpha, yminorgridlinewidth, yminorgridstyle, yminorticks, ymirror, yrotation, yscale, yshowaxis, ytick_direction, ytickfontcolor, ytickfontfamily, ytickfonthalign, ytickfontrotation, ytickfontsize, ytickfontvalign, yticks, yunitformat, ywiden, z, z_order, zdiscrete_values, zerror, zflip, zforeground_color_axis, zforeground_color_border, zforeground_color_grid, zforeground_color_text, zformatter, zgrid, zgridalpha, zgridlinewidth, zgridstyle, zguide, zguidefontcolor, zguidefontfamily, zguidefonthalign, zguidefontrotation, zguidefontsize, zguidefontvalign, zlims, zlink, zminorgrid, zminorgridalpha, zminorgridlinewidth, zminorgridstyle, zminorticks, zmirror, zrotation, zscale, zshowaxis, ztick_direction, ztickfontcolor, ztickfontfamily, ztickfonthalign, ztickfontrotation, ztickfontsize, ztickfontvalign, zticks, zunitformat, zwiden\n└ @ Plots ~/.julia/packages/Plots/zgMHY/src/args.jl:1563\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVemos que la edad es también un factor a tener en cuenta y el precio del billete que de algún modo también indica la clase o ventajas abordo.\nEn este caso debemos ver si las distribuciones de ambas columnas muestra simetría o están volcadas a uno de los ejes (skewness).\n\nplot(\n    density(df.Age),\n    density(df.Fare),\n    layout=(1,2)\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComo podemos ver, el precio del billete muestra una asimetría significativa que dificultará un análisis visual de los datos.\n\nusing DataFrames, StatsPlots\n\n# Agrupar por clase y sexo, calcular tasa de supervivencia\ndf_group = combine(groupby(df, [:Fare, :Age]), :Survived =&gt; mean =&gt; :SurvivalRate)\n\n# Convertir Sex a string para el eje y\ndf_group.Age = string.(df_group.Age)\n\n# Graficar: eje x = Fare, eje y = Age, tamaño/color = tasa de supervivencia\n@df df_group scatter(\n    :Fare,\n    :Age,\n    markersize = 15,\n    zcolor = :SurvivalRate,\n    xlabel = \"Precio\",\n    ylabel = \"Age\",\n    title = \"Tasa de supervivencia por precio del billete y edad\",\n    legend = :right,\n    cbar_title = \"Tasa de supervivencia\"\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPodemos compensar este echo mediante una transformación de la distribución empleando un logaritmo que reduzca la distancia de los valores más anómalos contra el centro de la distribución.\n\nplot(\n    histogram(df.Fare),\n    histogram(log.(df.Fare)),\n    layout=(1,2),\n    xlabel = [\"Precio del billete\" \"Log(Precio del billete)\"]\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@df df_group scatter(\n    log.(:Fare),\n    :Age,\n    markersize = 15,\n    zcolor = :SurvivalRate,\n    xlabel = \"Precio\",\n    ylabel = \"Age\",\n    title = \"Tasa de supervivencia por precio del billete y edad\",\n    legend = :right,\n    cbar_title = \"Tasa de supervivencia\"\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAunque no del todo claro, ahora podemos observar mejor una mayor concentración de tasas elevadas de superviviencia para los billetes más caros.",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Análisis exploratorio</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/exploratory.html#correlaciones",
    "href": "parts/dataframes/exploratory.html#correlaciones",
    "title": "8  Análisis exploratorio",
    "section": "8.3 Correlaciones",
    "text": "8.3 Correlaciones\nAún no encontramos un ecosistema cerrado como es el caso de Scikit-learn en Python o Tidyverse en R. En este caso, para mostrar correlaciones entre apres recurriremos a la librería PairPlots y su dependencia actual con respecto a Makie.\n\nimport Pkg\n\nPkg.add(\"PairPlots\")\nPkg.add(\"CairoMakie\")\n\n\nusing CairoMakie\nusing PairPlots\n\n# Selecciona solo columnas numéricas relevantes\ncols = [:Age, :Fare, :SibSp, :Parch, :Survived]\ndf_num = dropmissing(df[:, cols])\n\npairplot(\n    df_num =&gt; (\n        PairPlots.HexBin(colormap=Makie.cgrad([:transparent, :black])),\n        PairPlots.Scatter(filtersigma=2, color=:black),\n        PairPlots.Contour(color=:black),\n        PairPlots.MarginHist(),\n        PairPlots.MarginQuantileText(),\n        # New:\n        PairPlots.MarginQuantileLines(),\n    ),\n    fullgrid=true\n)\n\n\n\n\nResulta difícil ver las discrepancias así, de modo que separaremos nuestro conjunto en los dos grupos objeto de estudio.\n\n# Por categoría\ndf_num_survived = filter(:Survived =&gt; x -&gt; x == true, df_num)\ndf_num_didntsurvive = filter(:Survived =&gt; x -&gt; x == false, df_num)\n\npairplot(\n    PairPlots.Series(\n        df_num_survived, bottomleft=true, topright=false),\n    PairPlots.Series(\n        df_num_didntsurvive, bottomleft=false, topright=true)\n)\n\n\n\n\ncontinuará",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Análisis exploratorio</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias",
    "section": "",
    "text": "Bezanson, Jeff, Alan Edelman, Stefan Karpinski, and Viral B Shah. 2017.\n“Julia: A Fresh Approach to Numerical Computing.” SIAM\nReview 59 (1): 65–98.\n\n\nLattner, Chris, and Vikram Adve. 2004. “LLVM: A Compilation\nFramework for Lifelong Program Analysis & Transformation.” In\nInternational Symposium on Code Generation and Optimization, 2004.\nCGO 2004., 75–86. IEEE. https://llvm.org/pubs/2004-01-30-CGO-LLVM.pdf.\n\n\nStoropoli, Jose, Rik Huijzer, and Lazaro Alonso. 2021. Julia Data\nScience. https://juliadatascience.io.",
    "crumbs": [
      "Referencias"
    ]
  }
]