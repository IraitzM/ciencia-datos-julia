[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ciencia de datos con Julia",
    "section": "",
    "text": "Prólogo\nEste projecto lo inicio por haber querido emplear Julia en el ámbito profesional y no haber podido. Es mucho más habitual en mi entorno, por familiaridad y conveniencia, que los proyectos de ciencia de datos se realicen en otros lenguajes de programación. Sin embargo, quiero romper una lanza a favor de Julia como el lenguaje a emplear en ciencia de datos por su rendimiento y proximidad al dominio científico. Existen guía excepcionales en inglés:\nPero este es mi intento de acercarlo al público hispanohablante. Teniendo referencias en el idioma de uno es más fácil poder adoptar algo y crear una comunidad con contribuya tanto como lo hace la comunidad de Python.\nCon suerte este libro ayuda a más de uno a perder el miedo y enfrentarse a este lenguaje que no deja de ser uno de los motivos por los que nuestros amados notebooks son notebooks de Jupyter (Julia, python y R).",
    "crumbs": [
      "Prólogo"
    ]
  },
  {
    "objectID": "index.html#sobre-mi",
    "href": "index.html#sobre-mi",
    "title": "Ciencia de datos con Julia",
    "section": "Sobre mi",
    "text": "Sobre mi\nMi nombre es Iraitz Montalbán y llevo… algo de tiempo en esto de la ciencia de datos e inteligencia artificial. Puedes contactar directamente conmigo en iraitz.info.\n\n\n\n\nStoropoli, Jose, Rik Huijzer, and Lazaro Alonso. 2021. Julia Data Science. https://juliadatascience.io.",
    "crumbs": [
      "Prólogo"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introducción",
    "section": "",
    "text": "1.1 Instalar Julia\nPrimeramente debemos entender qué es Julia (Bezanson et al. 2017). Julia es un lenguaje de reciente creación (2012) de programación que pretende romper la barrera de los dos lenguajes. Es decir, ser rápido en ejecución pero cómodo en el uso, incluyendo el uso interactivo tan común en el trabajo exploratorio de la ciencia de datos. Está muy ligado al mundo de la computación científica y es común en centros de investigación o entes ligados a la computación de altas prestaciones (High Performance Computing). De hecho, Julia es parte del selecto club del petaflop. Está basado en el compilador LLVM (Lattner and Adve 2004) y de ahí que muestra una velocidad similar a la de otros lenguajes empleados en ambientes productivos (C/C++, Rust o Go).\nEs habitual que los científicos de datos desarrollen sus modelos en Python y una vez conformes con su rendimiento delegen la puesta en producción en ingenieros que deben transformar estos programas en código productivo. Suele requerir incorporar cuestiones no contempladas hasta el momento como logs de cara a depurar errores, bloques de seguridad y autenticación, sanitización1 del código para evitar problemas de seguridad y rendimiento, etc.\nJulia no podría ser más sencillo de instalar.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#instalar-julia",
    "href": "intro.html#instalar-julia",
    "title": "1  Introducción",
    "section": "",
    "text": "Linux/Mac\nSimplemente ejecuta el comando\ncurl -fsSL https://install.julialang.org | sh\ny se encargará de instalar el intérprete de Julia así como su gestor de versiones juliaup.\n\n\nWindows\nDeberemos instalarlo desde la Microsoft Store pero también podemos ejecutarlo desde una shell.\nwinget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\nUna vez instalado podemos hacer una pequeña prueba, levantar un terminal y ejecutar julia. Debería mostrarnos algo como\n\n\n\nJulia en el terminal\n\n\nAhora ya solo nos queda empezar a trabajar.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#crear-un-proyecto",
    "href": "intro.html#crear-un-proyecto",
    "title": "1  Introducción",
    "section": "1.2 Crear un proyecto",
    "text": "1.2 Crear un proyecto\nJulia trae por defecto un gestor de paquetes propio. Esto nos ayuda a indicar las dependencias de nuestro código para que pueda ejecutarse en otros entornos de manera correcta.\nPodemos crear un primer proyecto indicando la activación del mismo.\n\nimport Pkg;\nPkg.activate(\".\")\n\nEsto generará dos ficheros esenciales para el correcto funcionamiento de nuestro código:\n\nProject.toml: Donde se listan las dependencias de nuestro proyecto.\nManifest.toml: Donde se indican las versiones de nuestro intérprete de Julia a utilizar, además de los hash de las versiones de los paquetes compatibles.\n\nPodemos ver las distintas opciones en la documentación oficial. Podemos añadir una dependencia mediante la función .add()\n\nPkg.add(\"Plots\")\n\nY esta se sumará a nuestros ficheros TOML. El comando .status() nos informará de las dependencias actuales.\n\nPkg.status()\n\n\nStatus `~/work/ciencia-datos-julia/ciencia-datos-julia/Project.toml`\n  [336ed68f] CSV v0.10.15\n  [a93c6f00] DataFrames v1.7.0\n⌃ [91a5bcdd] Plots v1.40.15\nInfo Packages marked with ⌃ have new versions available and may be upgradable.\n\n\n\n\nDe forma que podemos hacer uso de esas librerías o paquetes en nuestro código.\n\nusing Plots\n\nplot(sin, \n     x-&gt;sin(2x), \n     0, \n     2π, \n     leg=false, \n     fill=(0,:lavender))\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1.1: Gráfico paramétrico, mostrando un ejemplo de uso de librería/paquete\n\n\n\n\nEste es un aspecto clave ya que, tal y como sucede en Python, mucho de nuestro trabajo dependerá de los paquetes existentes y así no tendremos que reinventar la rueda una y otra vez.\n\n\n\n\nBezanson, Jeff, Alan Edelman, Stefan Karpinski, and Viral B Shah. 2017. “Julia: A Fresh Approach to Numerical Computing.” SIAM Review 59 (1): 65–98.\n\n\nLattner, Chris, and Vikram Adve. 2004. “LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation.” In International Symposium on Code Generation and Optimization, 2004. CGO 2004., 75–86. IEEE. https://llvm.org/pubs/2004-01-30-CGO-LLVM.pdf.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  Introducción",
    "section": "",
    "text": "Proceso de revisar y limpiar el código fuente de un programa para eliminar errores, mejorar su calidad y asegurar que cumpla con estándares de seguridad y eficiencia.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html",
    "href": "parts/firststeps/basics.html",
    "title": "2  Básicos de Julia",
    "section": "",
    "text": "2.1 Variables\nEn estos primeros ejemplos veremos los rudimentos de la sintaxis de Julia. Y empezaremos con los básicos aunque dado que existen amplias coincidencias entre Julia y Python, asumiendo que el lector conoce las estructuras base de Python (listas, diccionarios, etc..) nos centraremos en las grandes diferencias.\nVeamos con una de las primeras acciones que será la definición de variables.\nx = 2\n\n2\nComo vemos Julia tiene tipado dinámico, no tenemos por qué definir el tipo de datos asociado al valor que hemos introducido.\ntypeof(x)\n\nInt64\nPodemos hacer lo mismo con múltiples tipos\nx = 2 + 1im\ntypeof(x)\n\nComplex{Int64}\nAunque podemos incluir el tipado si fuera necesario.\ny::Float16 = 120\ntypeof(y)\n\nFloat16\nEsto impedirá que hagamos cosas como\ncon un error MethodError: Cannot convert an object of type String to an object of type Float16 en nuestro caso, ya que el tipo declarado de la variable y el valor a asociar no coinciden. Trabajaremos principalmente con los tipos habituales\nPodemos crear tipos específicos para nuestras necesidades basado en esos tipos básicos.\nstruct Usuario\n    nombre::String\n    apellido::String\n    anio_nacimiento::Int64\nend\n\nUsuario(\"Iraitz\",\"Montalbán\", 1984)\n\nUsuario(\"Iraitz\", \"Montalbán\", 1984)\nComo vemos , Julia tiene por costumbre imprimir el valor de la última línea ejecutada. Por definición son estructuras inmutables, por lo que si queremos variar sus datos una vez inicializados deberemos indicarlo expresamente.\nmutable struct UsuarioMutable\n    nombre::String\n    apellido::String\n    anio_nacimiento::Int64\nend\n\niraitz = UsuarioMutable(\"Iraitz\",\"Montalban\", 1984)\niraitz.apellido = \"Montalbán\"\n\n\"Montalbán\"\nLas variables booleanas nos permiten operaciones lógicas:\n!true\n\nfalse\ntrue && false\n\nfalse\nO de pertenencia a un grupo o tipo, igualdad == y desigualdad !=, &lt;, etc.\n6 isa Real\n\ntrue",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html#variables",
    "href": "parts/firststeps/basics.html#variables",
    "title": "2  Básicos de Julia",
    "section": "",
    "text": "y = \"hola\"\n\n\nEnteros: Int64\nNúmeros reales: Float64\nBinarios (verdadero o falso): Bool\nCadenas de caracteres: String\n\n\n\n\n\n\n\n!: NOT\n&&: AND\n||: OR",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html#funciones",
    "href": "parts/firststeps/basics.html#funciones",
    "title": "2  Básicos de Julia",
    "section": "2.2 Funciones",
    "text": "2.2 Funciones\nOtro aspecto clave son las funciones. La lógica de nuestro programa que toma variables y devuelve variables basado en operaciones lógicas.\nfunction nombre_funcion(arg1, arg2)\n    resultado = hacemos cosas con arg1 y arg2\n    return resultado\nend\nTambién permite la definición mediate asignación, a modo de función lambda f_name(arg1, arg2) = hacemos cosas con arg1 y arg2 aunque por claridad emplearemos el modelo anterior.\nJulia permite especificar el tipo de argumentos haciendo que dos funciones con el mismo nombre apliquen distinta lógica en base a los argumentos de entrada y su tipo.\n\nfunction redondeo(x::Int64)\n    print(\"Es un entero\")\n    return x\nend\n\nfunction redondeo(x::Float64)\n    print(\"Es un número con decimales\")\n    return round(x)\nend\n\nmethods(redondeo)\n\n# 2 methods for generic function redondeo from \u001b[35mMain.Notebook\u001b[39m: redondeo(x::Float64) in Main.Notebook at /home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps/basics.qmd:114  redondeo(x::Int64) in Main.Notebook at /home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps/basics.qmd:109 \n\n\nEsto nos permite invocar a uno u otro únicamente en base al tipado.\n\nx = Float64(18)\n\nredondeo(x)\n\nEs un número con decimales\n\n\n18.0\n\n\nEn estos casos, si el tipado no coincide con ninguna de las definiciones de la función, Julia nos alertará con un error.\nPodemos también definir valores por defecto en los argumentos de entrada y devolver más de un elemento.\n\nfunction suma_y_multiplica(x::Int64, y::Int64 = 10)\n    suma = x + y\n    mult = x * y\n    return suma, mult\nend\n\nsuma_y_multiplica(5)\n\n(15, 50)\n\n\n\nsuma_y_multiplica(5, 5)\n\n(10, 25)\n\n\nEn caso de querer utilizar argumentos clave (keyword) estos se separan mediante el carácter ; y siempre deben disponer de un valor por defecto.\n\nfunction suma_y_multiplica(x::Int64; y::Int64 = 10)\n    suma = x + y\n    mult = x * y\n    return suma, mult\nend\n\nsuma_y_multiplica(5, y=7)\n\n(12, 35)\n\n\nPor último, en Julia existe la convención de añadir el carácter ! en caso de que la función altere o modifique alguno de sus argumentos.\n\nfunction suma_uno!(V)\n    for i in eachindex(V)\n        V[i] += 1\n    end\n    return nothing\nend\n\nsuma_uno! (generic function with 1 method)\n\n\nNo devolvemos nada pero si evaluamos el contenido de nuestro dato inicial, veremos que ha sido modificado.\n\ndatos = [1, 2, 3]\n\nsuma_uno!(datos)\n\ndatos\n\n3-element Vector{Int64}:\n 2\n 3\n 4",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/flujos.html",
    "href": "parts/firststeps/flujos.html",
    "title": "3  Flujos en Julia",
    "section": "",
    "text": "3.1 Condición (if)\nUna vez controlamos las estructuras base podremos aplicar distintas lógicas de flujo a la hora de evaluar nuestro código.\nLos flujos if muestran un funcionamiento similar a otros lenguajes de programación.\nLa sentencia debe iniciar con if y terminar con end. Internamente podemos evaluar condiciones adicionales con elseif o condiciones no contempladas con else.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Flujos en Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/flujos.html#condición-if",
    "href": "parts/firststeps/flujos.html#condición-if",
    "title": "3  Flujos en Julia",
    "section": "",
    "text": "a = 1\nb = 2\n\nif a &lt; b\n    \"a &lt; b\"\nelseif a &gt; b\n    \"a &gt; b\"\nelse\n    \"a == b\"\nend",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Flujos en Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/flujos.html#iteración-forwhile",
    "href": "parts/firststeps/flujos.html#iteración-forwhile",
    "title": "3  Flujos en Julia",
    "section": "3.2 Iteración (for/while)",
    "text": "3.2 Iteración (for/while)\nLos bucles nos permiten iterar durante un número definido de veces\nfor i in 1:3\n    # Hacer algo\nend\no bien, hasta que se cumpla una condición concreta. En este caso debemos indicar que i se trata de una variable global de forma que es accesible desde fuera del flujo (es decir, no local al bucle en curso).\ni = 0\n\nwhile i &lt; 3\n    # Hacer algo\n\n    # Esto es necesario para que salga del bucle\n    global i += 1\nend\nTambién podemos condicionar el bucle parando break o continuando a la siguiente iteración continue.\ni = 1;\n\nwhile true\n    println(i)\n    if i &gt;= 3\n        break\n    end\n    global i += 1\nend\nfor i = 1:10\n    if i % 3 != 0\n        continue\n    end\n    println(i)\nend\nMás detalle en Control flows.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Flujos en Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html",
    "href": "parts/firststeps/librerias.html",
    "title": "4  Módulos y librerías",
    "section": "",
    "text": "4.1 Fechas\nUn aspecto clave en los lenguajes de programación para ciencia de datos es el uso de librerías. Estas nos permiten atajar retos que otros ya han enfrentado y hacer uso de funciones ya creadas para el objeto.\nLa carga de módulos se hace mediante el comando using\nVeremos algunos módulos base que nos ayudarán con ciertas structuras de datos complejas de manejar.\nPara poder gestionar fechas deberemos importar un módulo específico\nusing Dates\nExisten dos tipos de fecha que deberemos manejar. Date para fechas sin tiempo informado\nDate(2025, 7, 3) # año, mes, dia\n\n2025-07-03\nY DateTime para fechas en las que dispongamos de hora.\nDateTime(2025, 7, 3, 12, 0) # año, mes, dia, hora, minutos\n\n2025-07-03T12:00:00\nPodremos también indicarlos basado en formato, como segundo argumento de nuestros dos tipos base.\nformat = DateFormat(\"yyyymmdd\")\nDate(\"19870913\", format)\n\n1987-09-13",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#fechas",
    "href": "parts/firststeps/librerias.html#fechas",
    "title": "4  Módulos y librerías",
    "section": "",
    "text": "Intervalos\nComo siempre con las fechas, podremos acceder a intervalos temporales (o periodos).\n\nfecha = Date(2025, 7, 1) \nperiodo = today() - fecha\n\n3 days\n\n\nPodemos ver que tipo soporta nuestra variable resultante.\n\ntypeof(periodo)\n\nDay\n\n\nLa función today() nos devuelve un Day por lo que si queremos más precisión, deberemos convertirlo a DateTime y usar now() en nuestra comparativa para que la resta sea entre los mismos tipos.\n\nfecha_hora_ms = DateTime(2025, 7, 1, 12, 1, 3, 120) # precisión de microsegundos \nlapso = now() - fecha_hora_ms\n\n248132966 milliseconds\n\n\n\ntypeof(lapso)\n\nMillisecond",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#descargas",
    "href": "parts/firststeps/librerias.html#descargas",
    "title": "4  Módulos y librerías",
    "section": "4.2 Descargas",
    "text": "4.2 Descargas\nExiste otro módulo que nos vendrá muy bien a la hora de descargarnos ficheros.\n\nusing Downloads\n\nPodremos indicarle a la función Downloads.download() la dirección desde la que descargar nuestro conjunto de datos.\n\nurl = \"https://raw.githubusercontent.com/IraitzM/ciencia-datos-julia/refs/heads/main/Project.toml\"\nfichero_proyecto = Downloads.download(url) # creamos un fichero temporal\n\n\"/tmp/jl_3E1sjuLm92\"\n\n\nY con funciones como readlines leer su contenido.\n\nreadlines(fichero_proyecto)\n\n4-element Vector{String}:\n \"[deps]\"\n \"CSV = \\\"336ed68f-0bac-5ca0-87d4-7b16caf5d00b\\\"\"\n \"DataFrames = \\\"a93c6f00-e57d-5684-b7b6-d8193f3e46c0\\\"\"\n \"Plots = \\\"91a5bcdd-55d7-5caf-9e0b-520d859cae80\\\"\"",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#paquetes-habituales",
    "href": "parts/firststeps/librerias.html#paquetes-habituales",
    "title": "4  Módulos y librerías",
    "section": "4.3 Paquetes habituales",
    "text": "4.3 Paquetes habituales\nEn el caso de tratarse de módulos no disponibles como parte de la librería standard, deberemos recurrir al gestor de paquetes e instalarlas.\nusing Pkg;\nPkg.add(\"Libreria.jl\")\nTal y como veíamos en la introducción estos paquetes serán añadidos a los dos ficheros clave que nos permiten reproducir nuestro entorno en otra máquina.\nLas librerías que emplearemos en líneas generales son:\n\nManipulación de datos: DataFrames.jl\nVisualización: Mackie.jl y Plots.jl\n\nTodos estos paquetes y más están disponibles en https://juliapackages.com/.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/sistemaficheros.html",
    "href": "parts/firststeps/sistemaficheros.html",
    "title": "5  Sistema de ficheros",
    "section": "",
    "text": "Como en todo lenguaje de programación, deberemos gestionar la lectura y escritura de ficheros. El sistema de ficheros lo gestiona el sistema operativo de nuestra máquina con lo que se trata más bien de interactuar con este al menos de cara a conocer por ejemplo, dónde estamos ubicados.\n\ndirname(@__FILE__)\n\n\"/home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps\"\n\n\nPodemos crear carpetas de forma programática pero en la mayoría de casos se tratará de leer y escribir ficheros en rutas concretas. Para ello nos será útil la función joinpath que nos ayuda a conformar rutas tal y como el sistema de ficheros requiere.\n\nroot = dirname(@__FILE__)\njoinpath(root, \"ejemplo.txt\")\n\n\"/home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps/ejemplo.txt\"\n\n\nY como vimos anteriormente, usar la función readlines() para leer su contenido.\n\nfichero = joinpath(root, \"ejemplo.txt\")\nreadline(fichero)\n\n\"Hola desde un fichero!\"\n\n\nImaginemos por tanto que queremos descargarnos un CSV (Comma Separated Value) con información sobre los pasajeros del Titanic\n\nusing Downloads\n\nfichero_url = \"https://raw.githubusercontent.com/datasciencedojo/datasets/refs/heads/master/titanic.csv\"\nfichero = Downloads.download(fichero_url)\nreadlines(fichero)[:20]\n\n\"19,0,3,\\\"Vander Planke, Mrs. Julius (Emelia Maria Vandemoortele)\\\",female,31,1,0,345763,18,,S\"\n\n\nSi queremos conservar el fichero para más adelante podemos recurrir a la función write() y guardarlo donde nosotros queramos.\n\nwrite(\"../../data/titanic.csv\", read(fichero))\n\n60302\n\n\nY podemos revisar el contenido iterando sobre walkdir() que recorre los elementos de un directorio.\n\nitr = walkdir(\"../../data/\")\n(root, dirs, files) = first(itr)\n\n(\"../../data/\", String[], [\".gitkeep\", \"titanic.csv\"])\n\n\nDisponemos de los comandos más usuales a la hora de crear un directorio (mkdir()) o adentrarnos en él (cd()). Tenéis más detalle sobre los comandos disponibles aquí.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Sistema de ficheros</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html",
    "href": "parts/dataframes/basics.html",
    "title": "6  Cargando datos",
    "section": "",
    "text": "6.1 CSV\nYa conocemos las bases de Julia y ahora toca empezar a ver cómo hacer uso de los recursos más comunes en ciencia de datos. Dado que en el ejemplo anterior ya hemos creado un fichero con datos del Titanic, veamos si podemos cargarlo.\nQuizás uno de los formatos más comunes en el mundo empresarial es el fichero de texto con extensión CSV (Comma Separated Value). Extraído habitualmente de ficheros Excel o bien de exportaciones de sistemas gestores de base de datos, veremos que presenta un formato tabular donde cada celda viene separado por un carácter (siendo , o ; los más habituales); y el salto de línea marca el inicio de una nueva fila.\nDado que leer y trabajar con estos ficheros puede ser tedioso, recurriremos a uno de las primeras librerías que nos serán de ayuda en nuestra tarea.Dos en realidad, CSV que sabe como tratar estos ficheros y DataFrames que nos ofrece todas las funcionalidades de las estructuras tabulares.\nusing Pkg;\nPkg.add(\"CSV\")\nPkg.add(\"DataFrames\")\nusing CSV, DataFrames\n\ndf = CSV.read(\"../../data/titanic.csv\", DataFrame)\nfirst(df)\n\nDataFrameRow (12 columns)\n\n\n\nRow\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\nInt64\nInt64\nInt64\nString\nString7\nFloat64?\nInt64\nInt64\nString31\nFloat64\nString15?\nString1?\n\n\n\n\n1\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.25\nmissing\nS",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias",
    "section": "",
    "text": "Bezanson, Jeff, Alan Edelman, Stefan Karpinski, and Viral B Shah. 2017.\n“Julia: A Fresh Approach to Numerical Computing.” SIAM\nReview 59 (1): 65–98.\n\n\nLattner, Chris, and Vikram Adve. 2004. “LLVM: A Compilation\nFramework for Lifelong Program Analysis & Transformation.” In\nInternational Symposium on Code Generation and Optimization, 2004.\nCGO 2004., 75–86. IEEE. https://llvm.org/pubs/2004-01-30-CGO-LLVM.pdf.\n\n\nStoropoli, Jose, Rik Huijzer, and Lazaro Alonso. 2021. Julia Data\nScience. https://juliadatascience.io.",
    "crumbs": [
      "Referencias"
    ]
  }
]