[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ciencia de datos con Julia",
    "section": "",
    "text": "Prólogo\nEste projecto lo inicio por haber querido emplear Julia en el ámbito profesional y no haber podido. Es mucho más habitual en mi entorno, por familiaridad y conveniencia, que los proyectos de ciencia de datos se realicen en otros lenguajes de programación. Sin embargo, quiero romper una lanza a favor de Julia como el lenguaje a emplear en ciencia de datos por su rendimiento y proximidad al dominio científico. Existen guía excepcionales en inglés:\nY algunas muy buenas referencias de programación en Julia en Español.\nPero este es mi intento de acercarlo al público hispanohablante. Teniendo referencias en el idioma de uno es más fácil poder adoptar algo y crear una comunidad con contribuya tanto como lo hace la comunidad de Python.\nCon suerte este libro ayuda a más de uno a perder el miedo y enfrentarse a este lenguaje que no deja de ser uno de los motivos por los que nuestros amados notebooks son notebooks de Jupyter (Julia, python y R).",
    "crumbs": [
      "Prólogo"
    ]
  },
  {
    "objectID": "index.html#sobre-mí",
    "href": "index.html#sobre-mí",
    "title": "Ciencia de datos con Julia",
    "section": "Sobre mí",
    "text": "Sobre mí\nMi nombre es Iraitz Montalbán y llevo… algo de tiempo en esto de la ciencia de datos e inteligencia artificial. Puedes contactar directamente conmigo en iraitz.info.\n\n\n\n\nStoropoli, Jose, Rik Huijzer, y Lazaro Alonso. 2021. Julia Data Science. https://juliadatascience.io.",
    "crumbs": [
      "Prólogo"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introducción",
    "section": "",
    "text": "1.1 Instalar Julia\nPrimeramente debemos entender qué es Julia (Bezanson et al. 2017). Julia es un lenguaje de reciente creación (2012) de programación que pretende romper la barrera de los dos lenguajes. Es decir, ser rápido en ejecución pero cómodo en el uso, incluyendo el uso interactivo tan común en el trabajo exploratorio de la ciencia de datos. Está muy ligado al mundo de la computación científica y es común en centros de investigación o entes ligados a la computación de altas prestaciones (High Performance Computing). De hecho, Julia es parte del selecto club del petaflop. Está basado en el compilador LLVM (Lattner y Adve 2004) y de ahí que muestra una velocidad similar a la de otros lenguajes empleados en ambientes productivos (C/C++, Rust o Go).\nEs habitual que los científicos de datos desarrollen sus modelos en Python y una vez conformes con su rendimiento delegen la puesta en producción en ingenieros que deben transformar estos programas en código productivo. Suele requerir incorporar cuestiones no contempladas hasta el momento como logs de cara a depurar errores, bloques de seguridad y autenticación, sanitización1 del código para evitar problemas de seguridad y rendimiento, etc.\nJulia no podría ser más sencillo de instalar.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#instalar-julia",
    "href": "intro.html#instalar-julia",
    "title": "1  Introducción",
    "section": "",
    "text": "Linux/Mac\nSimplemente ejecuta el comando\ncurl -fsSL https://install.julialang.org | sh\ny se encargará de instalar el intérprete de Julia así como su gestor de versiones juliaup.\n\n\nWindows\nDeberemos instalarlo desde la Microsoft Store pero también podemos ejecutarlo desde una shell.\nwinget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\nUna vez instalado podemos hacer una pequeña prueba, levantar un terminal y ejecutar julia. Debería mostrarnos algo como\n\n\n\nJulia en el terminal\n\n\nAhora ya solo nos queda empezar a trabajar.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#crear-un-proyecto",
    "href": "intro.html#crear-un-proyecto",
    "title": "1  Introducción",
    "section": "1.2 Crear un proyecto",
    "text": "1.2 Crear un proyecto\nJulia trae por defecto un gestor de paquetes propio. Esto nos ayuda a indicar las dependencias de nuestro código para que pueda ejecutarse en otros entornos de manera correcta.\nPodemos crear un primer proyecto indicando la activación del mismo.\n\nimport Pkg;\nPkg.activate(\".\")\n\nEsto generará dos ficheros esenciales para el correcto funcionamiento de nuestro código:\n\nProject.toml: Donde se listan las dependencias de nuestro proyecto.\nManifest.toml: Donde se indican las versiones de nuestro intérprete de Julia a utilizar, además de los hash de las versiones de los paquetes compatibles.\n\nPodemos ver las distintas opciones en la documentación oficial. Podemos añadir una dependencia mediante la función .add()\n\nPkg.add(\"Plots\")\n\nY esta se sumará a nuestros ficheros TOML. El comando .status() nos informará de las dependencias actuales.\n\nPkg.status()\n\n\nStatus `~/work/ciencia-datos-julia/ciencia-datos-julia/Project.toml`\n  [91a5bcdd] Plots v1.40.16\n\n\n\n\nDe forma que podemos hacer uso de esas librerías o paquetes en nuestro código.\n\nusing Plots\n\nplot(sin, \n     x-&gt;sin(2x), \n     0, \n     2π, \n     leg=false, \n     fill=(0,:lavender))\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigura 1.1: Gráfico paramétrico, mostrando un ejemplo de uso de librería/paquete\n\n\n\n\nEste es un aspecto clave ya que, tal y como sucede en Python, mucho de nuestro trabajo dependerá de los paquetes existentes y así no tendremos que reinventar la rueda una y otra vez.\n\n\n\n\nBezanson, Jeff, Alan Edelman, Stefan Karpinski, y Viral B Shah. 2017. «Julia: A fresh approach to numerical computing». SIAM review 59 (1): 65-98.\n\n\nLattner, Chris, y Vikram Adve. 2004. «LLVM: A compilation framework for lifelong program analysis & transformation». En International symposium on code generation and optimization, 2004. CGO 2004., 75-86. IEEE. https://llvm.org/pubs/2004-01-30-CGO-LLVM.pdf.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  Introducción",
    "section": "",
    "text": "Proceso de revisar y limpiar el código fuente de un programa para eliminar errores, mejorar su calidad y asegurar que cumpla con estándares de seguridad y eficiencia.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html",
    "href": "parts/firststeps/basics.html",
    "title": "2  Básicos de Julia",
    "section": "",
    "text": "2.1 Variables\nEn estos primeros ejemplos veremos los rudimentos de la sintaxis de Julia. Y empezaremos con los básicos aunque dado que existen amplias coincidencias entre Julia y Python, asumiendo que el lector conoce las estructuras base de Python (listas, diccionarios, etc..) nos centraremos en las grandes diferencias.\nVeamos con una de las primeras acciones que será la definición de variables.\nx = 2\n\n2\nComo vemos Julia tiene tipado dinámico, no tenemos por qué definir el tipo de datos asociado al valor que hemos introducido.\ntypeof(x)\n\nInt64\nPodemos hacer lo mismo con múltiples tipos\nx = 2 + 1im\ntypeof(x)\n\nComplex{Int64}\nAunque podemos incluir el tipado si fuera necesario.\ny::Float16 = 120\ntypeof(y)\n\nFloat16\nEsto impedirá que hagamos cosas como\ncon un error MethodError: Cannot convert an object of type String to an object of type Float16 en nuestro caso, ya que el tipo declarado de la variable y el valor a asociar no coinciden. Trabajaremos principalmente con los tipos habituales\nPodemos crear tipos específicos para nuestras necesidades basado en esos tipos básicos.\nstruct Usuario\n    nombre::String\n    apellido::String\n    anio_nacimiento::Int64\nend\n\nUsuario(\"Iraitz\",\"Montalbán\", 1984)\n\nUsuario(\"Iraitz\", \"Montalbán\", 1984)\nComo vemos , Julia tiene por costumbre imprimir el valor de la última línea ejecutada. Por definición son estructuras inmutables, por lo que si queremos variar sus datos una vez inicializados deberemos indicarlo expresamente.\nmutable struct UsuarioMutable\n    nombre::String\n    apellido::String\n    anio_nacimiento::Int64\nend\n\niraitz = UsuarioMutable(\"Iraitz\",\"Montalban\", 1984)\niraitz.apellido = \"Montalbán\"\n\n\"Montalbán\"\nLas variables booleanas nos permiten operaciones lógicas:\n!true\n\nfalse\ntrue && false\n\nfalse\nO de pertenencia a un grupo o tipo, igualdad == y desigualdad !=, &lt;, etc.\n6 isa Real\n\ntrue",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html#variables",
    "href": "parts/firststeps/basics.html#variables",
    "title": "2  Básicos de Julia",
    "section": "",
    "text": "y = \"hola\"\n\n\nEnteros: Int64\nNúmeros reales: Float64\nBinarios (verdadero o falso): Bool\nCadenas de caracteres: String\n\n\n\n\n\n\n\n!: NOT\n&&: AND\n||: OR",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html#arrays",
    "href": "parts/firststeps/basics.html#arrays",
    "title": "2  Básicos de Julia",
    "section": "2.2 Arrays",
    "text": "2.2 Arrays\nLas listas de datos funcionan de forma muy similar a las listas en Python.\n\na = [1, 2, 3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\nVemos que el tipo por defecto se llama Vector{} y en corchetes marca nuestro tipo para los elementos. Esto implica que si un elemento requiere un tipado mayor, este se les asignará también al resto, siendo Any (cualquiera) la opción más general.\n\na = [1, 2, \"hola\"]\n\n3-element Vector{Any}:\n 1\n 2\n  \"hola\"\n\n\nPodemos separar en filas nuestros elementos y así generar un vector de dos dimensiones o matriz.\n\na = [1 2 3; 4 5 6]\n\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\nY podemos así extender a las dimensiones que necesitemos nuestros elementos multidimensionales. El acceso a los datos se realiza por índices o rangos, teniendo en cuenta el número de índices de nuestro vector. Quizás una de las cuestiones más relevantes viniendo de lenguajes como Python es que Julia cuenta lso elementos iniciando en 1 en lugar de 0. Por lo tanto pedir el elemento a[0] nos dará un error.\n\na[1]\n\n1\n\n\n\na[1:2]\n\n2-element Vector{Int64}:\n 1\n 4\n\n\n\na[:, 1:2]\n\n2×2 Matrix{Int64}:\n 1  2\n 4  5\n\n\n\na[2, 2]\n\n5\n\n\nTampoco funcionarán los índices negativos ya que deberemos usar la palabra reservada end.\n\na[end, end]\n\n6",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/basics.html#funciones",
    "href": "parts/firststeps/basics.html#funciones",
    "title": "2  Básicos de Julia",
    "section": "2.3 Funciones",
    "text": "2.3 Funciones\nOtro aspecto clave son las funciones. La lógica de nuestro programa que toma variables y devuelve variables basado en operaciones lógicas.\nfunction nombre_funcion(arg1, arg2)\n    resultado = hacemos cosas con arg1 y arg2\n    return resultado\nend\nTambién permite la definición mediate asignación, a modo de función lambda f_name(arg1, arg2) = hacemos cosas con arg1 y arg2 aunque por claridad emplearemos el modelo anterior.\nJulia permite especificar el tipo de argumentos haciendo que dos funciones con el mismo nombre apliquen distinta lógica en base a los argumentos de entrada y su tipo.\n\nfunction redondeo(x::Int64)\n    print(\"Es un entero\")\n    return x\nend\n\nfunction redondeo(x::Float64)\n    print(\"Es un número con decimales\")\n    return round(x)\nend\n\nmethods(redondeo)\n\n# 2 methods for generic function redondeo from \u001b[35mMain.Notebook\u001b[39m: redondeo(x::Float64) in Main.Notebook at /home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps/basics.qmd:157  redondeo(x::Int64) in Main.Notebook at /home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps/basics.qmd:152 \n\n\nEsto nos permite invocar a uno u otro únicamente en base al tipado.\n\nx = Float64(18)\n\nredondeo(x)\n\nEs un número con decimales\n\n\n18.0\n\n\nEn estos casos, si el tipado no coincide con ninguna de las definiciones de la función, Julia nos alertará con un error.\nPodemos también definir valores por defecto en los argumentos de entrada y devolver más de un elemento.\n\nfunction suma_y_multiplica(x::Int64, y::Int64 = 10)\n    suma = x + y\n    mult = x * y\n    return suma, mult\nend\n\nsuma_y_multiplica(5)\n\n(15, 50)\n\n\n\nsuma_y_multiplica(5, 5)\n\n(10, 25)\n\n\nEn caso de querer utilizar argumentos clave (keyword) estos se separan mediante el carácter ; y siempre deben disponer de un valor por defecto.\n\nfunction suma_y_multiplica(x::Int64; y::Int64 = 10)\n    suma = x + y\n    mult = x * y\n    return suma, mult\nend\n\nsuma_y_multiplica(5, y=7)\n\n(12, 35)\n\n\nPor último, en Julia existe la convención de añadir el carácter ! en caso de que la función altere o modifique alguno de sus argumentos.\n\nfunction suma_uno!(V)\n    for i in eachindex(V)\n        V[i] += 1\n    end\n    return nothing\nend\n\nsuma_uno! (generic function with 1 method)\n\n\nNo devolvemos nada pero si evaluamos el contenido de nuestro dato inicial, veremos que ha sido modificado.\n\ndatos = [1, 2, 3]\n\nsuma_uno!(datos)\n\ndatos\n\n3-element Vector{Int64}:\n 2\n 3\n 4\n\n\nExisten toda una serie de funciones que podemos emplear directamente desde la consola. Tenemos operadores básicos como suma o multiplicación, y otras funcionalidades no tan básicas como la selección de los primeros o últimos elementos de un vector, la creación de números aleatorios o el poder fijar una semilla para dicha generación aleatoria.\n\nMacros\nComo último apunte, veréis que existen sentencias que iniciamos con el carácter @. Estas son conocidas como macros, operaciones que nos permiten simplificar la sintaxis y que en muchos casos hacen referencia a funciones con el mismo nombre.\n\n@time print(\"Hemos tardado en imprimir esta línea\")\n\nHemos tardado en imprimir esta línea  0.000044 seconds (10 allocations: 64.281 KiB)\n\n\n\n\n\n\n\n\nMacro creada por nosotros\n\n\n\n\n\n\nmacro es_entero(x)\n   if typeof(x) == Int64  \n      return \"Es un entero\"\n   end\n   return \"No es un entero\"\nend\n\n@es_entero 5\n\n\"Es un entero\"\n\n\n\n\n\nMás que listar todas estas operaciones y estructuras disponibles, iremos viendo con ejemplos las más usuales según avancemos en los materiales.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Básicos de Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/flujos.html",
    "href": "parts/firststeps/flujos.html",
    "title": "3  Flujos en Julia",
    "section": "",
    "text": "3.1 Condición (if)\nUna vez controlamos las estructuras base podremos aplicar distintas lógicas de flujo a la hora de evaluar nuestro código.\nLos flujos if muestran un funcionamiento similar a otros lenguajes de programación.\nLa sentencia debe iniciar con if y terminar con end. Internamente podemos evaluar condiciones adicionales con elseif o condiciones no contempladas con else.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Flujos en Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/flujos.html#condición-if",
    "href": "parts/firststeps/flujos.html#condición-if",
    "title": "3  Flujos en Julia",
    "section": "",
    "text": "a = 1\nb = 2\n\nif a &lt; b\n    \"a &lt; b\"\nelseif a &gt; b\n    \"a &gt; b\"\nelse\n    \"a == b\"\nend",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Flujos en Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/flujos.html#iteración-forwhile",
    "href": "parts/firststeps/flujos.html#iteración-forwhile",
    "title": "3  Flujos en Julia",
    "section": "3.2 Iteración (for/while)",
    "text": "3.2 Iteración (for/while)\nLos bucles nos permiten iterar durante un número definido de veces\nfor i in 1:3\n    # Hacer algo\nend\no bien, hasta que se cumpla una condición concreta. En este caso debemos indicar que i se trata de una variable global de forma que es accesible desde fuera del flujo (es decir, no local al bucle en curso).\ni = 0\n\nwhile i &lt; 3\n    # Hacer algo\n\n    # Esto es necesario para que salga del bucle\n    global i += 1\nend\nTambién podemos condicionar el bucle parando break o continuando a la siguiente iteración continue.\ni = 1;\n\nwhile true\n    println(i)\n    if i &gt;= 3\n        break\n    end\n    global i += 1\nend\nfor i = 1:10\n    if i % 3 != 0\n        continue\n    end\n    println(i)\nend\nMás detalle en Control flows.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Flujos en Julia</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html",
    "href": "parts/firststeps/librerias.html",
    "title": "4  Módulos y librerías",
    "section": "",
    "text": "4.1 Fechas\nUn aspecto clave en los lenguajes de programación para ciencia de datos es el uso de librerías. Estas nos permiten atajar retos que otros ya han enfrentado y hacer uso de funciones ya creadas para el objeto.\nLa carga de módulos se hace mediante el comando using\nVeremos algunos módulos base que nos ayudarán con ciertas structuras de datos complejas de manejar.\nPara poder gestionar fechas deberemos importar un módulo específico\nusing Dates\nExisten dos tipos de fecha que deberemos manejar. Date para fechas sin tiempo informado\nDate(2025, 7, 3) # año, mes, dia\n\n2025-07-03\nY DateTime para fechas en las que dispongamos de hora.\nDateTime(2025, 7, 3, 12, 0) # año, mes, dia, hora, minutos\n\n2025-07-03T12:00:00\nPodremos también indicarlos basado en formato, como segundo argumento de nuestros dos tipos base.\nformat = DateFormat(\"yyyymmdd\")\nDate(\"19870913\", format)\n\n1987-09-13",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#fechas",
    "href": "parts/firststeps/librerias.html#fechas",
    "title": "4  Módulos y librerías",
    "section": "",
    "text": "Intervalos\nComo siempre con las fechas, podremos acceder a intervalos temporales (o periodos).\n\nfecha = Date(2025, 7, 1) \nperiodo = today() - fecha\n\n5 days\n\n\nPodemos ver que tipo soporta nuestra variable resultante.\n\ntypeof(periodo)\n\nDay\n\n\nLa función today() nos devuelve un Day por lo que si queremos más precisión, deberemos convertirlo a DateTime y usar now() en nuestra comparativa para que la resta sea entre los mismos tipos.\n\nfecha_hora_ms = DateTime(2025, 7, 1, 12, 1, 3, 120) # precisión de microsegundos \nlapso = now() - fecha_hora_ms\n\n457475664 milliseconds\n\n\n\ntypeof(lapso)\n\nMillisecond",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#descargas",
    "href": "parts/firststeps/librerias.html#descargas",
    "title": "4  Módulos y librerías",
    "section": "4.2 Descargas",
    "text": "4.2 Descargas\nExiste otro módulo que nos vendrá muy bien a la hora de descargarnos ficheros.\n\nusing Downloads\n\nPodremos indicarle a la función Downloads.download() la dirección desde la que descargar nuestro conjunto de datos.\n\nurl = \"https://raw.githubusercontent.com/IraitzM/ciencia-datos-julia/refs/heads/main/parts/firststeps/ejemplo.txt\"\n\nfichero_proyecto = Downloads.download(url) # creamos un fichero temporal\n\n\"/tmp/jl_Iv2n2TSRC5\"\n\n\nY con funciones como readlines leer su contenido.\n\nreadlines(fichero_proyecto)\n\n1-element Vector{String}:\n \"Hola desde un fichero!\"\n\n\nVemos que devuelve una estructura de Vector con cadenas de texto (String) con el contenido del fichero.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#aleatorios",
    "href": "parts/firststeps/librerias.html#aleatorios",
    "title": "4  Módulos y librerías",
    "section": "4.3 Aleatorios",
    "text": "4.3 Aleatorios\nTrabajar con números aleatorios es habitual en ciencia de datos, y para ello podemos recurrir al módulo Random\n\nusing Random\n\nRandom.seed!(1234)\nRandom.randn()\n\n-0.3597289068234817",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/librerias.html#paquetes-habituales",
    "href": "parts/firststeps/librerias.html#paquetes-habituales",
    "title": "4  Módulos y librerías",
    "section": "4.4 Paquetes habituales",
    "text": "4.4 Paquetes habituales\nEn el caso de tratarse de módulos no disponibles como parte de la librería standard, deberemos recurrir al gestor de paquetes e instalarlas.\nusing Pkg;\nPkg.add(\"Libreria.jl\")\nTal y como veíamos en la introducción estos paquetes serán añadidos a los dos ficheros clave que nos permiten reproducir nuestro entorno en otra máquina.\nLas librerías que emplearemos en líneas generales son:\n\nManipulación de datos: DataFrames.jl\nVisualización: Mackie.jl y Plots.jl\n\nTodos estos paquetes y más están disponibles en https://juliapackages.com/.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Módulos y librerías</span>"
    ]
  },
  {
    "objectID": "parts/firststeps/sistemaficheros.html",
    "href": "parts/firststeps/sistemaficheros.html",
    "title": "5  Sistema de ficheros",
    "section": "",
    "text": "Como en todo lenguaje de programación, deberemos gestionar la lectura y escritura de ficheros. El sistema de ficheros lo gestiona el sistema operativo de nuestra máquina con lo que se trata más bien de interactuar con este al menos de cara a conocer por ejemplo, dónde estamos ubicados.\n\ndirname(@__FILE__)\n\n\"/home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps\"\n\n\nPodemos crear carpetas de forma programática pero en la mayoría de casos se tratará de leer y escribir ficheros en rutas concretas. Para ello nos será útil la función joinpath que nos ayuda a conformar rutas tal y como el sistema de ficheros requiere.\n\nroot = dirname(@__FILE__)\njoinpath(root, \"ejemplo.txt\")\n\n\"/home/runner/work/ciencia-datos-julia/ciencia-datos-julia/parts/firststeps/ejemplo.txt\"\n\n\nY como vimos anteriormente, usar la función readlines() para leer su contenido.\n\nfichero = joinpath(root, \"ejemplo.txt\")\nreadline(fichero)\n\n\"Hola desde un fichero!\"\n\n\nImaginemos por tanto que queremos descargarnos un CSV (Comma Separated Value) con información sobre los pasajeros del Titanic\n\nusing Downloads\n\nfichero_url = \"https://raw.githubusercontent.com/datasciencedojo/datasets/refs/heads/master/titanic.csv\"\nfichero = Downloads.download(fichero_url)\nreadlines(fichero)[:20]\n\n\"19,0,3,\\\"Vander Planke, Mrs. Julius (Emelia Maria Vandemoortele)\\\",female,31,1,0,345763,18,,S\"\n\n\nSi queremos conservar el fichero para más adelante podemos recurrir a la función write() y guardarlo donde nosotros queramos.\n\nwrite(\"../../data/titanic.csv\", read(fichero))\n\n60302\n\n\nY podemos revisar el contenido iterando sobre walkdir() que recorre los elementos de un directorio.\n\nitr = walkdir(\"../../data/\")\n(root, dirs, files) = first(itr)\n\n(\"../../data/\", String[], [\".gitkeep\", \"titanic.csv\", \"titanic.json\", \"titanic.parquet\"])\n\n\nDisponemos de los comandos más usuales a la hora de crear un directorio (mkdir()) o adentrarnos en él (cd()). Tenéis más detalle sobre los comandos disponibles aquí.",
    "crumbs": [
      "Primeros pasos",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Sistema de ficheros</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html",
    "href": "parts/dataframes/basics.html",
    "title": "6  Cargando datos",
    "section": "",
    "text": "6.1 CSV\nYa conocemos las bases de Julia y ahora toca empezar a ver cómo hacer uso de los recursos más comunes en ciencia de datos. Dado que en el ejemplo anterior ya hemos creado un fichero con datos del Titanic, veamos si podemos cargarlo.\nQuizás uno de los formatos más comunes en el mundo empresarial es el fichero de texto con extensión CSV (Comma Separated Value). Extraído habitualmente de ficheros Excel o bien de exportaciones de sistemas gestores de base de datos, veremos que presenta un formato tabular donde cada celda viene separado por un carácter (siendo , o ; los más habituales); y el salto de línea marca el inicio de una nueva fila.\nDado que leer y trabajar con estos ficheros puede ser tedioso, recurriremos a uno de las primeras librerías que nos serán de ayuda en nuestra tarea.Dos en realidad, CSV que sabe como tratar estos ficheros y DataFrames que nos ofrece todas las funcionalidades de las estructuras tabulares.\nusing Pkg;\nPkg.add(\"CSV\")\nPkg.add(\"DataFrames\")\nusing CSV, DataFrames\n\ndf = CSV.read(\"../../data/titanic.csv\", DataFrame)\nfirst(df)\n\nDataFrameRow (12 columns)\n\n\n\nRow\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\nInt64\nInt64\nInt64\nString\nString7\nFloat64?\nInt64\nInt64\nString31\nFloat64\nString15?\nString1?\n\n\n\n\n1\n1\n0\n3\nBraund, Mr. Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.25\nmissing\nS\nPodemos extender este uso sobre la carga de datos tabulares a otros formatos comunes como Excel gracias a librerías como XLSX.jl",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html#json",
    "href": "parts/dataframes/basics.html#json",
    "title": "6  Cargando datos",
    "section": "6.2 JSON",
    "text": "6.2 JSON\nOtro formato habitual, particularmente cuando trabajamos contra APIs es JSON. Necesitaremos entender las estructuras de estos documentos de cara a darles el formato tabular adecuado.\n\nreadlines(\"../../data/titanic.json\")\n\n20946-element Vector{String}:\n \"[\"\n \"  {\"\n \"    \\\"pclass\\\": 1,\"\n \"    \\\"survived\\\": 1,\"\n \"    \\\"name\\\": \\\"Allen, Miss. Elisabeth Walton\\\",\"\n \"    \\\"sex\\\": \\\"female\\\",\"\n \"    \\\"age\\\": 29,\"\n \"    \\\"sibsp\\\": 0,\"\n \"    \\\"parch\\\": 0,\"\n \"    \\\"ticket\\\": 24160,\"\n ⋮\n \"    \\\"ticket\\\": 315082,\"\n \"    \\\"fare\\\": 7.875,\"\n \"    \\\"cabin\\\": \\\"\\\",\"\n \"    \\\"embarked\\\": \\\"S\\\",\"\n \"    \\\"boat\\\": \\\"\\\",\"\n \"    \\\"body\\\": \\\"\\\",\"\n \"    \\\"home.dest\\\": \\\"\\\"\"\n \"  }\"\n \"]\"\n\n\nPodemos ver que en este caso disponemos de una lista de objetos con un único nivel de datos que podemos trasladar directamente a un DataFrame.\n\nusing Pkg;\nPkg.add(\"JSON\")\n\n\nusing JSON, DataFrames\n\n# Leemos las lineas y las juntamos en una cadena única\ndata = join(readlines(\"../../data/titanic.json\"))\n\ndf = DataFrame(JSON.parse(data))\nfirst(df)\n\nDataFrameRow (14 columns)\n\n\n\nRow\nsex\nage\nparch\nboat\nname\nhome.dest\ncabin\nfare\nembarked\nbody\nsibsp\npclass\nsurvived\nticket\n\n\n\nString\nAny\nInt64\nAny\nString\nString\nString\nAny\nString\nAny\nInt64\nInt64\nInt64\nAny\n\n\n\n\n1\nfemale\n29.0\n0\n2\nAllen, Miss. Elisabeth Walton\nSt Louis, MO\nB5\n211.338\nS\n\n0\n1\n1\n24160\n\n\n\n\n\n\nEs importante prestar atención a la estructura del JSON ya que si dispone de múltiples anidamientos y objetos complejos será difícil disponer de una estructura tabular plana directamente sin necesitar trabajo de preprocesado y aplanado previo.",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html#parquet",
    "href": "parts/dataframes/basics.html#parquet",
    "title": "6  Cargando datos",
    "section": "6.3 Parquet",
    "text": "6.3 Parquet\nSi hay un formato omnipresente desde que fue creado allá por 2013 es Parquet. Formato columnar y comprimido por defecto, permite trabajar con estructuras de datos tabulares de forma eficiente para los procesos analíticos, con una huella de almacenamiento mínima y compatible con multitud de las herramientas de stack de ciencia de datos. De hecho, es la base para estructuras de almacenamiento más complejas que ofrecen capacidades ACID como Iceberg o Delta Lake.\n\nusing Pkg;\nPkg.add(\"Parquet\")\n\n\nusing Parquet\n\nread_parquet(\"../../data/titanic.parquet\")\n\nParquet.Table(\"../../data/titanic.parquet\")\n\n\nPodemos cargar el contenido directamente como DataFrame gracias a la compatibilidad entre estas dos librerías.\nusing Parquet, DataFrames\n\ndf = DataFrame(read_parquet(\"../../data/titanic.parquet\"))\nfirst(df)\nExisten otras dos grandes fuentes con las que será necesario interactuar para formar nuestro elenco de opciones.",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html#apis",
    "href": "parts/dataframes/basics.html#apis",
    "title": "6  Cargando datos",
    "section": "6.4 APIs",
    "text": "6.4 APIs\nInteractuar con APIs requiere realizar consultas siguiendo el protocolo HTTP y obtener los datos de respuesta en un formato compatible. En nuestro caso, al haber visto como el formato JSON es manejable gracias a la librería de Julia, simplemente deberemos añadir librerías de manejo del protocolo en concreto.\n\nusing Pkg;\nPkg.add(\"HTTP\")\n\n\nusing HTTP\nusing JSON\n\n# Dirección para el echo de postman\nurl=\"https://postman-echo.com/get?foo1=bar1&foo2=bar2\"\n\nrespuesta = HTTP.get(url)\ntexto_respuesta = String(respuesta.body)\nJSON.parse(texto_respuesta)[\"args\"]\n\nDict{String, Any} with 2 entries:\n  \"foo1\" =&gt; \"bar1\"\n  \"foo2\" =&gt; \"bar2\"\n\n\nPodéis probar con otras APIs donde poder cargar los datos directamente en un DataFrame. Tomemos como ejemplo la PokeAPI\n\nusing HTTP\nusing JSON\n\n# Dirección para el echo de postman\nurl=\"https://pokeapi.co/api/v2/pokemon?limit=10\"\n\nrespuesta = HTTP.get(url)\ntexto_respuesta = String(respuesta.body)\n\ndf = DataFrame(JSON.parse(texto_respuesta)[\"results\"])\nfirst(df, 5)\n\n5×2 DataFrame\n\n\n\nRow\nname\nurl\n\n\n\nString\nString\n\n\n\n\n1\nbulbasaur\nhttps://pokeapi.co/api/v2/pokemon/1/\n\n\n2\nivysaur\nhttps://pokeapi.co/api/v2/pokemon/2/\n\n\n3\nvenusaur\nhttps://pokeapi.co/api/v2/pokemon/3/\n\n\n4\ncharmander\nhttps://pokeapi.co/api/v2/pokemon/4/\n\n\n5\ncharmeleon\nhttps://pokeapi.co/api/v2/pokemon/5/",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/basics.html#sistemas-gestores-de-base-de-datos",
    "href": "parts/dataframes/basics.html#sistemas-gestores-de-base-de-datos",
    "title": "6  Cargando datos",
    "section": "6.5 Sistemas gestores de Base de Datos",
    "text": "6.5 Sistemas gestores de Base de Datos\nLos sistemas gestores de base de datos son un recurso habitual donde deberemos de encontrar el modo de poder enviar nuestras consultas (empleando SQL) y obtener una estructura que encaje en nuestros DataFrames.\nPara la mayoría de casos deberemos encontrar la librería compatible con nuestra base de datos dado que la especificación de cada una puede variar y requeriremos cierta librería en cada caso.\n\nSQLite\nDuckDB\nMySQL\nPostgreSQL\n\nY más que podéis encontrar en https://juliapackages.com/c/database.\n\nusing Pkg;\nPkg.add(\"DuckDB\")\n\n\nusing DuckDB\n\ncon_duckdb = DBInterface.connect(DuckDB.DB, \"bd.duckdb\")\n\nDuckDB.DB(\"bd.duckdb\")\n\n\nUna vez conectados podemos leer de los datos del entorno.\n\n# Creamos una serie de datos aleatorios\nlen = 10_000\ndatos = (a = collect(1:len), b = rand(1:100, len))\n\n# Create la tabla\ncreate_query = \"\nCREATE TABLE IF NOT EXISTS data(\n  a INT NOT NULL,\n  b INT NOT NULL\n);\"\nDBInterface.execute(con_duckdb, create_query);\n\nInsertamos los datos de prueba.\n\n\n\n\n\n\nTip\n\n\n\nCon @time podemos ver el tiempo que le toma realizar la tarea en cuestión.\n\n\n\n# Escribimos los datos\nstr = join(repeat('?', length(datos)), ',')\nwrite_query = DBInterface.prepare(con_duckdb, \"INSERT INTO data VALUES($str)\")\n@time DBInterface.executemany(write_query, datos)\n\n  2.330438 seconds (185.07 k allocations: 7.969 MiB, 2.20% compilation time)\n\n\nY podemos proceder a leer parte de estos.\n\n@time table_rd = DBInterface.execute(con_duckdb, \"SELECT * FROM data\")\n\n  0.000691 seconds (18 allocations: 640 bytes)\n\n\n(a = Int32[1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  9991, 9992, 9993, 9994, 9995, 9996, 9997, 9998, 9999, 10000], b = Int32[66, 98, 71, 55, 4, 63, 39, 2, 12, 64  …  85, 81, 48, 47, 94, 81, 76, 4, 16, 70])\n\n\nLa lectura puede realizarse directamente formando el DataFrame resultante a utilizar ya que las bases de datos relacionales siempre nos retornan estructuras tabulares.\n\ndf = DataFrame(DBInterface.execute(con_duckdb, \"SELECT * FROM data\"))\nfirst(df, 5)\n\n5×2 DataFrame\n\n\n\nRow\na\nb\n\n\n\nInt32\nInt32\n\n\n\n\n1\n1\n66\n\n\n2\n2\n98\n\n\n3\n3\n71\n\n\n4\n4\n55\n\n\n5\n5\n4\n\n\n\n\n\n\nSiempre deberemos de acordarnos de cerrar la conexión una vez que hayamos obtenido los datos de la fuente.\n\nDBInterface.close!(con_duckdb)",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cargando datos</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/summary.html",
    "href": "parts/dataframes/summary.html",
    "title": "7  Análisis preliminar",
    "section": "",
    "text": "7.1 Distribuciones de datos\nPartimos de nuestros datos ya cargados, y deberemos ver la estructura base de nuestro dataframe. La función describe nos ofrece una primera revisión de los datos indicando nombre de las columnas, estadísticas de la distribución de datos, valores faltantes y typo de dato.\nA esto podemos unirle conocer el tamaño de nuestro conjunto mediante el método size.\nUna de las mejores formes de conocer las distribuciones de datos es precisamente visualizando su histograma o gráfico de densidad. Deberéis instalar los paquetes de visualización pertinentes.\nPkg.add(\"StatsPlots\")\nusing StatsPlots\n\nhistogram(df.Age, normalize=true)\nVemos que si lo comparamos con una distribución normal, las gráficas difieren bastante. Esto suele requerir de evaluar la normalidad de la\nEl primer reto al que nos enfrentaremos será el de poder mostrar el diagrama de densidad, ya que no permite la existencia de valores faltantes. Y como podemos ver existen varios para la columna age. Deberemos aprender a filtrar en base a una condición.",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis preliminar</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/summary.html#distribuciones-de-datos",
    "href": "parts/dataframes/summary.html#distribuciones-de-datos",
    "title": "7  Análisis preliminar",
    "section": "",
    "text": "Gráfico de distribución normal\n\n\n\n\n\n\nPkg.add(\"Distributions\")\n\n\nusing Distributions\n\nplot(Normal(3, 5), lw=3)",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis preliminar</span>"
    ]
  },
  {
    "objectID": "parts/dataframes/summary.html#valores-faltantes",
    "href": "parts/dataframes/summary.html#valores-faltantes",
    "title": "7  Análisis preliminar",
    "section": "7.2 Valores faltantes",
    "text": "7.2 Valores faltantes\nEn el caso de Julia missing es un tipo de datos especial que no indica el valor faltante en una celda.\n\ntypeof(missing)\n\nMissing\n\n\nExisten funciones específicas para eliminar o simplemente filtrar en base a la condición de dato faltante (ismissing). En este caso podremos ver los primeros tres elementos en nuestro dataframe donde se cumple la condición de dato faltante en el campo edad (:Age).\n\nfirst(\n    filter(\n        :Age =&gt; ismissing, df\n    ),\n    3\n)\n\n3×12 DataFrame\n\n\n\nRow\nPassengerId\nSurvived\nPclass\nName\nSex\nAge\nSibSp\nParch\nTicket\nFare\nCabin\nEmbarked\n\n\n\nInt64\nInt64\nInt64\nString\nString7\nFloat64?\nInt64\nInt64\nString31\nFloat64\nString15?\nString1?\n\n\n\n\n1\n6\n0\n3\nMoran, Mr. James\nmale\nmissing\n0\n0\n330877\n8.4583\nmissing\nQ\n\n\n2\n18\n1\n2\nWilliams, Mr. Charles Eugene\nmale\nmissing\n0\n0\n244373\n13.0\nmissing\nS\n\n\n3\n20\n1\n3\nMasselmani, Mrs. Fatima\nfemale\nmissing\n0\n0\n2649\n7.225\nmissing\nC\n\n\n\n\n\n\nY así podemos ver la densidad indicando nuestro dataframe modificado para que no cumpla esta condición. StatsPlots nos da la opción de explorar otras macros (ya vimos la macro de @time) que en este caso será el turno de @df. Esta macro, empleada con la sintaxis\n@df &lt;tabla&gt; &lt;función de visualización&gt;\nnos permite definir una estructura tabular que luego será empleada en la función de visualización a la que solo deberemos indicarle en qué columnas centrarse.\n\n@df filter(:Age =&gt; !ismissing, df) density(:Age)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComo vemos, la función de densidad nos presenta un perímetro continuo sobre el histograma anterior. Podemos evaluar la normalidad de nuestra columna empleando tests estadísticos. La librería HypothesisTests.jl nos dará buenas referencias de cuales podemos usar.\nPor simplificar de momento, viendo que la media y la mediana muestra valores parejos para el intervalo de datos, asumiremos dicha normalidad y veremos como imputar la media como valor estimado a los datos faltantes de nuestro dataframe.\n\nusing Statistics\n\nmean(skipmissing(df.Age))\n\n29.69911764705882\n\n\nEste valor lo reemplazaremos indicando que queremos transformar (alterando el objeto df)\n\ntransform!(df, :Age =&gt; ByRow(x -&gt; coalesce(x, mean(skipmissing(df.Age)))); renamecols=false)\ndescribe(df)\n\n12×7 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\nnmissing\neltype\n\n\n\nSymbol\nUnion…\nAny\nUnion…\nAny\nInt64\nType\n\n\n\n\n1\nPassengerId\n446.0\n1\n446.0\n891\n0\nInt64\n\n\n2\nSurvived\n0.383838\n0\n0.0\n1\n0\nInt64\n\n\n3\nPclass\n2.30864\n1\n3.0\n3\n0\nInt64\n\n\n4\nName\n\nAbbing, Mr. Anthony\n\nvan Melkebeke, Mr. Philemon\n0\nString\n\n\n5\nSex\n\nfemale\n\nmale\n0\nString7\n\n\n6\nAge\n29.6991\n0.42\n29.6991\n80.0\n0\nFloat64\n\n\n7\nSibSp\n0.523008\n0\n0.0\n8\n0\nInt64\n\n\n8\nParch\n0.381594\n0\n0.0\n6\n0\nInt64\n\n\n9\nTicket\n\n110152\n\nWE/P 5735\n0\nString31\n\n\n10\nFare\n32.2042\n0.0\n14.4542\n512.329\n0\nFloat64\n\n\n11\nCabin\n\nA10\n\nT\n687\nUnion{Missing, String15}\n\n\n12\nEmbarked\n\nC\n\nS\n2\nUnion{Missing, String1}\n\n\n\n\n\n\nTras esto, con las dos columnas restantes podemos optar por eliminar estos datos. dropmissing eliminará las filas que contengan valores faltantes en sus celdas.\n\ndf_sinfilas = dropmissing(df)\nsize(df_sinfilas)\n\n(202, 12)\n\n\nO mediante la función select podemos indicarle que no queremos las columnas con datos faltantes. Para esta macro deberemos usar otro paquete muy habitual para este tipo de labores.\n\nPkg.add(\"DataFramesMeta\")\n\n\nusing DataFramesMeta\n\ndescribe(select(df, Not(:Cabin, :Embarked)))\n\n10×7 DataFrame\n\n\n\nRow\nvariable\nmean\nmin\nmedian\nmax\nnmissing\neltype\n\n\n\nSymbol\nUnion…\nAny\nUnion…\nAny\nInt64\nDataType\n\n\n\n\n1\nPassengerId\n446.0\n1\n446.0\n891\n0\nInt64\n\n\n2\nSurvived\n0.383838\n0\n0.0\n1\n0\nInt64\n\n\n3\nPclass\n2.30864\n1\n3.0\n3\n0\nInt64\n\n\n4\nName\n\nAbbing, Mr. Anthony\n\nvan Melkebeke, Mr. Philemon\n0\nString\n\n\n5\nSex\n\nfemale\n\nmale\n0\nString7\n\n\n6\nAge\n29.6991\n0.42\n29.6991\n80.0\n0\nFloat64\n\n\n7\nSibSp\n0.523008\n0\n0.0\n8\n0\nInt64\n\n\n8\nParch\n0.381594\n0\n0.0\n6\n0\nInt64\n\n\n9\nTicket\n\n110152\n\nWE/P 5735\n0\nString31\n\n\n10\nFare\n32.2042\n0.0\n14.4542\n512.329\n0\nFloat64\n\n\n\n\n\n\nYa tenemos un conjunto de datos algo más limpio. Ahora toca estudiarlo en profundidad.",
    "crumbs": [
      "Carga y exploración",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis preliminar</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Referencias",
    "section": "",
    "text": "Bezanson, Jeff, Alan Edelman, Stefan Karpinski, and Viral B Shah. 2017.\n“Julia: A Fresh Approach to Numerical Computing.” SIAM\nReview 59 (1): 65–98.\n\n\nLattner, Chris, and Vikram Adve. 2004. “LLVM: A Compilation\nFramework for Lifelong Program Analysis & Transformation.” In\nInternational Symposium on Code Generation and Optimization, 2004.\nCGO 2004., 75–86. IEEE. https://llvm.org/pubs/2004-01-30-CGO-LLVM.pdf.\n\n\nStoropoli, Jose, Rik Huijzer, and Lazaro Alonso. 2021. Julia Data\nScience. https://juliadatascience.io.",
    "crumbs": [
      "Referencias"
    ]
  }
]